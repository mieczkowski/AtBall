% \ref{fig:rysunek} - odniesienie do rysunku, "sec" do rozdzia≥u
% ~\footnote{To jest w≥aúnie przypis.}
%\begin{equation}
%    \label{eq:rownanie}
%    i(t) =  \left(i_0 - {E\over R}\right)e^{-(R/L) t} + {E\over R}.
%\end{equation}

%\part{WstÍp}
%\label{part:x}
\newcommand{\code}[1]{\mbox{\textcolor{blue}{\texttt{#1}}}}
\newcommand{\atbold}[1]{\textbf{#1}}
\newcommand{\sourceBegin}[2]{\begin{lstlisting}[caption={#1},label={code:#2}]}
\newcommand{\sourceEnd}{\end{lstlisting}}


\definecolor{darkgray}{rgb}{0.95,0.95,0.95}
\lstset{ %
language=C++,                % choose the language of the code
basicstyle=\footnotesize,       % the size of the fonts that are used for the code
numbers=none,                   % where to put the line-numbers
backgroundcolor=\color{darkgray},  % choose the background color. You must add \usepackage{color}
showspaces=false,               % show spaces adding particular underscores
showstringspaces=false,         % underline spaces within strings
showtabs=false,                 % show tabs within strings adding particular underscores
tabsize=2,                % sets default tabsize to 2 spaces
captionpos=b,                   % sets the caption-position to bottom
breaklines=true,                % sets automatic line breaking
breakatwhitespace=false,        % sets if automatic breaks should only happen at whitespace
keywordstyle=\color{royalblue}\bfseries, %\emph
escapeinside={\%*}{*)}%,         % if you want to add a comment within your code
}

% ********** Rozdzia≥ 1 - WstÍp **********
\chapter{WstÍp}
\label{Wstep}
Niniejszy rozdzia≥ ma formÍ wstÍpu do pozosta≥ej czÍúci pracy. Zosta≥ podzielony na trzy czÍúci. Pierwsza czÍúÊ zawiera wyjaúnienie tematu. Druga przedstawia cel oraz za≥oøenia jakie przyjπ≥ autor przygotowujπc projekt. Trzecia zawiera konspekt i ogÛlny podzia≥ pracy.

\section{Temat pracy}
\label{Wstep:Temat}
Aplikacja komputerowa to program udostÍpniajπcy uøytkownikowi okreúlone funkcje i wykonujπcy zadane zadania. Moøna je podzieliÊ na dwie grupy: \textbf{sterowane zdarzeniami} i \textbf{czasu rzeczywistego}.\\

Aplikacje sterowane zdarzeniami dzia≥ajπ w oparciu o reakcje lub dane wprowadzane przez uøytkownika. Dobrym przyk≥adem sπ tutaj dynamiczne serwisy WWW. Generujπ one swojπ treúÊ wynikowπ na podstawie informacji wprowadzonych przez osobÍ. Kolejnym przyk≥adem sπ aplikacje do obs≥ugi baz danych. Uøytkownik wprowadza kryteria wyszukiwania, nastÍpnie aplikacja po otrzymaniu informacji wykonuje operacje niezbÍdne do pobrania konkretnych danych, zwraca je uøytkownikowi i czeka na dalsze polecenia.\\

Aplikacje czasu rzeczywistego sπ rozbudowaniem aplikacji sterowanych zdarzeniami. Mimo øe mogπ reagowaÊ na sygna≥y zewnÍtrzne, wykonujπ w tle inne czynnoúci. Idealnym przyk≥adem takiej aplikacji jest gra komputerowa, ktÛrej g≥Ûwnym elementem jest pÍtla. Wykonuje siÍ ona nieprzerwanie przez ca≥y okres dzia≥ania aplikacji. NajczÍúciej w jej sk≥ad wchodzi:
\begin{enumerate}
    \item Pobranie informacji dotyczπcych interakcji uøytkownika
    \item Uaktualnienie stanu logicznego w zaleønoúci od reakcji uøytkownika oraz minionego czasu od poprzedniego cyklu (np. fizyki, düwiÍku, kamery, pozycji obiektÛw w scenie)
    \item Generowanie wynikowego obrazu (wykonanie jednej klatki, na ktÛre sk≥ada siÍ przekszta≥cenie wierzcho≥kÛw modeli do pozycji docelowej, na≥oøenie tekstur oraz úwiate≥, aø do wyliczenia docelowego koloru piksela na ekranie)
\end{enumerate}

Taka iloúÊ operacji jest bardzo kosztowna obliczeniowo. Aby zachowaÊ p≥ynnoúÊ gry i animacji aplikacja powinna wyúwietlaÊ obraz z prÍdkoúciπ od 15 do 30 FPS~\footnote{ang: Frames Per Second - Klatek na sekundÍ}, poniewaø tyle wystarczy aby oszukaÊ ludzki wzrok i przekonaÊ o p≥ynnoúci. Naleøy w tym celu po≥oøyÊ duøy nacisk na metody optymalizacyjne takie jak wy≥πczenie obiektÛw niezawierajπcych siÍ w polu widzenia kamery z procesu renderingu, ktÛry jest najbardziej z≥oøony obliczeniowo.

\section{Cel pracy}
\label{Wstep:Cel}
Stworzenie rozbudowanej gry to skomplikowany i d≥ugoplanowy proces, w ktÛry zaangaøowanych jest co najmniej kilka osÛb. Autor z powodu ograniczeÒ czasowych oraz ma≥ego doúwiadczenia w tworzeniu tego typu aplikacji obra≥ sobie za cel zaimplementowanie prostego silnika graficznego, oraz na jego podstawie stworzenie ma≥ej gry zrÍcznoúciowej.\\

Nacisk zosta≥ po≥oøony na dwa zagadnienia wystÍpujπce w kaødej wiÍkszej produkcji:
\begin{itemize}
    \item Realistyczna fizyka. Do tego celu wykorzystany zosta≥ silnik fizyczny \textbf{PhysX} firmy \textbf{NVIDIA}.
    \item Uøycie zewnÍtrznych skryptÛw do oddzielenia logiki aplikacji od kodu ürÛd≥owego silnika. Sπ to  pliki tekstowe, ktÛre sπ interpretowane~\footnote{kaøda instrukcja jest czytana z pliku i wykonywana} podczas dzia≥ania aplikacji. WybÛr pad≥ na jÍzyk skryptowy \textbf{LUA}.
\end{itemize}

\section{Zakres pracy}
\label{Wstep:Zakres}
Praca zosta≥a podzielona na 4 g≥Ûwne czÍúci.
\begin{enumerate}
    \item WstÍp, ktÛry ma na celu wprowadzenie czytelnika w temat oraz przedstawia cel pracy
    \item CzÍúÊ teoretyczna zawierajπca opis technologii oraz bibliotek, stanowiπcy swoisty wstÍp do czÍúci implementacyjnej projektu
    \item CzÍúÊ praktyczna opisujπca proces powstawania oraz implementacji silnika graficznego oraz w≥aúciwej gry
    \item Podsumowanie, w ktÛrym autor wyciπga wnioski odnoúnie ukoÒczonej pracy, a takøe problemy na jakie natrafi≥ podczas procesu implementacji
\end{enumerate}


% ********** Koniec wstÍpu **********

% ********** Rozdzia≥ 2 - TEORIA **********

\chapter{Teoria}
\label{Teoria}

% ********** Rozdzia≥ 2 - TEORIA - START **********

\section{Wprowadzenie}
\label{Teoria:Wprowadzenie}

CzÍúÊ teoretyczna stanowi wprowadzenie teoretyczne do tematu tworzenia gier komputerowych. Zawarte sπ w niej nastÍpujπce informacje:
\begin{enumerate}
    \item Definicja, rodzaje, historia oraz proces tworzenia gry komputerowej
    \item Podstawowe pojÍcia oraz definicje zwiπzane z wyúwietlaniem grafiki w 3D
    \item Zapoznanie z bibliotekπ Microsoft DirectX oraz jej elementami
    \item OmÛwienie procesu tworzenia jednej klatki obrazu czyli proces renderingu
    \item Przedstawienie silnika fizycznego NVIDIA PhysX
    \item KrÛtkie wprowadzenie w tematykÍ jÍzykÛw skryptowych na podstawie jÍzyka Lua
\end{enumerate}

\section{Gry komputerowe}
\label{Teoria:Gry}
\subsection{Czym jest gra komputerowa?}
\label{Teoria:Gry:CzymJest}
\textbf{Gra komputerowa} jest aplikacjπ komputerowπ, ktÛra dostarcza uøytkownikowi dawki rozrywki poprzez wykonywanie okreúlonych zadaÒ wp≥ywajπc na obiekty oraz ich zachowanie w sztucznie stworzonym úrodowisku. W zaleønoúci od typu gry, zawiera ona cel oraz okreúlone zasady, ktÛrymi trzeba siÍ kierowaÊ, aby ukoÒczyÊ poziom lub ca≥π grÍ. Bardziej otwarte produkcje umoøliwiajπ dowolnπ (nieskoÒczonπ) grÍ w obrÍbie wirtualnego úwiata. Przyk≥adem takich sπ symulatory pojazdÛw (np. pociπgÛw) lub internetowe gry wieloosobowe, w ktÛrych rozrywka toczy siÍ na bieøπco, umoøliwiajπc graczom praktycznie nieskoÒczonπ zabawÍ.\\

Podajπc definicjÍ gry komputerowej warto wspomnieÊ o pojÍciu \mbox{\textbf{gry~konsolowej}}. Do jej uruchomienia wymagana jest zewnÍtrzna konsola przeznaczona wy≥πcznie do gier, dziÍki czemu (w przeciwieÒstwie do gry uruchamianej na komputerze) ca≥a moc obliczeniowa moøe zostaÊ wykorzystana na potrzeby gry. Przyk≥adem najpopularniejszych konsol do gier sπ Xbox firmy Microsoft oraz \mbox{PlayStation 3} firmy Sony.\\

Prezentacja g≥Ûwnych gatunkÛw gier:
\begin{itemize}
    \item \textbf{Platformowe i zrÍcznoúciowe} -- Gra polegajπca na kierowaniu postaciπ lub innym obiektem oraz pokonywanie przeszkÛd. W przypadku gier zrÍcznoúciowych sterowanie najczÍúciej wymaga zrÍcznoúci i dok≥adnoúci w celu ukoÒczenia poziomu lub planszy.
%http://www.pbernert.com/gamesold.htm
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/spyro.jpg}
\caption{Spyro The Dragon}
%\label{fig:LABEL}
\end{figure}
    \item \textbf{Strategiczne} -- Strategie skupiajπ siÍ na odpowiednim planowaniu militarnym w celu efektywnego wykorzystania jednostek do pokonania przeciwnika oraz ekonomicznym gospodarowaniu surowcami. Gatunek ten dzieli siÍ na \textbf{Strategiczne gry turowe} (TBS~\footnote{ang: TBS -- Turn-based strategy}) oraz \textbf{Strategie Czasu Rzeczywistego} (RTS~\footnote{ang: RTS -- Real-time strategy})
%http://www.forums.wiaderko.com/gry-strategiczne-i-gry-ekonomiczne/46745-[download]-[pc][rs]-age-empires-ii.html
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/age_of_empires.jpg}
\caption{Age of empires 2}
%\label{fig:LABEL}
\end{figure}
    \item \textbf{RPG~\footnote{ang: Role Playing Games}} -- Po≥πczenie gry platformowej i przygodowej. G≥Ûwny aspekt gier RPG to dbanie o rozwÛj swojej postaci. Przypisanych jest do niej wiele cech, ktÛre sπ rozwijane w trakcie trwania gry. OprÛcz tego w wiÍkszoúci gier kaøda postaÊ musi dokonaÊ wyboru jednej z profesji np. wojownik, czarodziej, ork, lub innych przewidzianych dla danej fabu≥y, ktÛre wstÍpnie zwiÍkszajπ wybrane w≥aúciwoúci (np mocniejsza magia ale s≥absze pos≥ugiwanie mieczem). Popularnπ w ostatnich latach odmianπ sπ gry MMORPG~\footnote{ang: Massively Multiplayer Online Role Playing Games}, dziÍki ktÛrym tysiπce graczy z ca≥ego úwiata mogπ siÍ zmierzyÊ w wirtualnym úwiecie.
%http://www.k-ff.com/phpbb2/viewtopic.php?t=4474
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/ff9.jpg}
\caption{Final Fantasy 9 -- RPG w úwiecie fantasy}
%\label{fig:LABEL}
\end{figure}
    \item \textbf{Logiczne} -- G≥Ûwnym celem tych gier sπ zagadki i ≥amig≥Ûwki, ktÛre naleøy rozwiπzaÊ aby ukoÒczyÊ grÍ. RÛwnieø gry wieloosobowe takie jak szachy i warcaby zaliczane sπ do tego gatunku.
%http://www.eliassen.co.uk/2009/04/24/solutions-for-crazy-machines-for-iphone-spoiler/
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/crazymachines.jpg}
\caption{Crazy Machines -- rozwiπzywanie fizycznych ≥amig≥Ûwek}
%\label{fig:LABEL}
\end{figure}
    \item \textbf{Przygodowe (fabularne)} -- Gry, w ktÛrych zrÍcznoúciowe sterowanie jest ograniczone do minimum a g≥Ûwny nacisk po≥oøony jest na fabu≥Í oraz rozwiπzywanie zagadek.
%http://www.bit-tech.net/gaming/pc/2007/10/08/how_to_write_an_adventure_game/1
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/Fahrenheit.jpg}
\caption{Fahrenheit -- gra fabularna}
%\label{fig:LABEL}
\end{figure}
    \item \textbf{Sportowe} -- Emulujπ tradycyjne gry takie jak pi≥ka noøna, baseball, golf itp. 
%http://www.nirmaltv.com/2008/07/07/fifa-2009-to-have-over-250-additions-and-enhancements/
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/fifa2009.jpg}
\caption{Fifa 2009 -- pi≥ka noøna}
%\label{fig:LABEL}
\end{figure}
    \item \textbf{Wyúcigowe} -- Popularny gatunek, w ktÛrym gracz zasiada za sterami samochodÛw lub innych pojazdÛw i bierze udzia≥ w wyúcigach, w celu pokonania komputerowych przeciwnikÛw, lub w przypadku gry przez internet - innych graczy.
%http://www.grysamochodowe.net/t/kariera-need-for-speed/
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/nfs.jpg}
\caption{Need For Speed Carbon -- wyúcigi uliczne}
%\label{fig:LABEL}
\end{figure}
    \item \textbf{Symulacyjne} -- Symulatory symulujπ úrodowisko, w ktÛrym gracz moøe cieszyÊ siÍ rzeczywistymi warunkami np. kierowania pociπgiem lub latania samolotem. NiektÛre gry symulacyjne dodajπ pewne za≥oøenia lub cel wymagany do ukoÒczenia gry np. zestrzelenie odpowiedniej iloúci samolotÛw, podczas gdy inne (np. The~Sims) umoøliwiajπ grÍ bez øadnych ograniczeÒ.
%http://www.kollewin.com/blog/ms-train-simulator/
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/train.jpg}
\caption{Microsoft Train Simulator -- Symulator jazdy pociπgiem}
%\label{fig:LABEL}
\end{figure}
\end{itemize}

\subsection{Historia gier komputerowych}
\label{Teoria:Gry:Historia}
Historia gier komputerowych, mimo dynamicznego rozwoju w latach siedemdziesiπtych, zosta≥a zapoczπtkowana w 1947 roku, kiedy to Thomas T. Goldsmith Jr. i Estle Ray Mann zaprojektowali symulacjÍ pocisku rakietowego uderzanego w wyznaczony cel na oscyloskopie CRT~\footnote{ang: Cathode-Ray Tube - kineskop z dzia≥em elektronowym}. Kπt wystrzelenia pocisku oraz jego prÍdkoúÊ by≥a sterowana odpowiednimi ga≥kami. \\

Kolejnym krokiem by≥o przeniesienie na ekran monitora gry \mbox{KÛ≥ko i Krzyøyk}, a w 1958 roku stworzenie przez Wiliama Higinbothana gry \mbox{Tennis for Two}.
%http://pl.wikipedia.org/w/index.php?title=Plik:Tennis_for_Two.jpg&filetimestamp=20060916015609
\begin{figure}[h]
\centering
\includegraphics[width=60mm]{img/1stgame.jpg}
\caption{Tennis for Two - jedna z pierwszych gier komputerowych}
%\label{fig:LABEL}
\end{figure}

W 1961 powsta≥a pierwsza ogÛlnodostÍpna i wp≥ywowa gra \mbox{Spacewar!} zaprojektowana przez grupÍ studentÛw z MIT~\footnote{Massachusetts Institute of Technology}, ktÛra zosta≥a zaprezentowana rok pÛüniej podczas MIT Science Open House.\\

W 1969 roku Ralph Baer (dwa lata po stworzeniu pistoletu úwietlnego) stworzy≥ prototyp pierwszej konsoli do gier wideo. Po sprzedaniu go firmie Magnavox, wydana zosta≥a w 1972 roku pod nazwπ \mbox{Magnavox Odyssey}. \\

Poczπtek lat siedemdziesiπtych to rÛwnieø start automatÛw do gry, ktÛre za pieniπdze umoøliwia≥y zabawÍ w rÛøne gry. Mimo braku sukcesu po wydaniu pierwszego modelu umoøliwiajπcego grÍ w Spacewar! z powodu zbyt duøej trudnoúci gry, firma Atari osiπgnÍ≥a sukces wydajπc automat do gry PONG. \\

Prawdziwy wzrost zainteresowania wirtualnπ rozrywkπ nastπpi≥ po stworzeniu i rozpowszechnieniu pierwszych komputerÛw osobistych, dziÍki czemu co raz wiÍcej osÛb mog≥o cieszyÊ siÍ grami w domu. Przez kolejne lata razem z rozwojem technologii komputerowej, nowych technologii wyúwietlania obrazu oraz bibliotek programistycznych, a takøe moøliwoúci sprzÍtowych takich jak karty graficzne, powstawa≥y co raz to nowoczeúniejsze produkcje, zapewniajπce jeszcze bardziej realistyczne efekty wizualne.
%http://www.cdaction.pl/news-5054/wyniki-sprzedazy-konsol-ps3-w-polsce.html
\begin{figure}[h]
\centering
\includegraphics[width=60mm]{img/ps3.jpg}
\caption{Konsola Sony PlayStation 3}
%\label{fig:LABEL}
\end{figure}
Koniec XX wieku przyniÛs≥ szybki rozwÛj konsol wideo. Dominujπcymi modelami by≥y konsole GameBoy, Playstation, \mbox{Sega Saturn} oraz \mbox{Nintendo 64}. Z poczπtkiem XXI wieku nasta≥y czasy nowych wersji konsol takich jak \mbox{Playstation 2}, Xbox, Dreamcast, aø do dzisiejszych czasÛw, w ktÛrych dominujπ \mbox{Playstation 3}, Wii oraz \mbox{Xbox 360}.

\subsection{Proces tworzenia gry komputerowej}
\label{Teoria:Gry:Tworzenie}
Tworzenie gry komputerowej to bardzo z≥oøony proces, dlatego podczas produkcji zaangaøowanych jest od kilku do nawet kilkuset osÛb. NajczÍúciej przyjmowanπ metodπ projektowπ jest poniøszy schemat:
\begin{enumerate}
    \item \textbf{Pomys≥} -- Pierwszym krokiem przy tworzeniu gry komputerowej jest decyzja odnoúnie typu gry, analiza zainteresowania wúrÛd docelowych odbiorcÛw oraz ustalenie wstÍpnych informacji dotyczπcych moøliwoúci budøetowych oraz ludzkich niezbÍdnych do pomyúlnego zrealizowania projektu.
    \item \textbf{Projektowanie} -- W tej fazie tworzy siÍ dokument zawierajπcy informacje o grze. Musi w nim byÊ zawarty pomys≥ gry, jej cele i fabu≥a, gatunek oraz docelowa grupa odbiorcÛw. Kolejnym etapem jest tworzenie dokumentacji projektu~\footnote{tzw. Design Doc}, w ktÛrym zawarte sπ wszystkie informacje o grze. Dokument ten jest podstawπ do dalszych prac nad projektem.
    \item \textbf{Tworzenie prototypu} -- Prototyp jest produktem, ktÛry ma pokazaÊ ogÛlne za≥oøenia projektu oraz przyk≥adowy wyglπd. NajczÍúciej jest to przyk≥adowy poziom gry pokazujπcy podstawowe aspekty sterowania i fabu≥y. DziÍki takiemu rozwiπzaniu projektanci mogπ uzupe≥niÊ braki w dokumentacji projektowej, oraz zwrÛciÊ uwagÍ na problemy, ktÛre mogπ wystπpiÊ przy tworzeniu w≥aúciwej gry.
    \item \textbf{Produkcja gry} -- Kiedy Design Doc jest gotowy nastÍpuje projektowanie i implementacja w≥aúciwego silnika gry. Na tym etapie kierownicy rozdzielajπ zadania pomiÍdzy zespo≥y programistÛw, grafikÛw i designerÛw. Po zaimplementowaniu ca≥ej funkcjonalnoúci nastÍpuje przejúcie do fazy testowania.
    \item \textbf{Testowanie i usuwanie b≥ÍdÛw} -- Testowanie jest jednym z najwaøniejszych etapÛw tworzenia gry. Od zespo≥u testerÛw oraz wykonanej przez nich pracy zaleøy sukces ca≥ego przedsiÍwziÍcia. Zbyt duøa liczba krytycznych b≥ÍdÛw lub niedociπgniÍÊ po wydaniu gry moøe negatywnie wp≥ynπÊ na recenzje produktu oraz zraziÊ odbiorcÛw do kupna.
    \item \textbf{Wydanie i marketing} -- Kaødy projekt ma wyznaczane kamienie~milowe~\footnote{ang: Milestone}, ktÛre okreúlajπ planowane ukoÒczenie poszczegÛlnych czÍúci projektu. W przypadku pozytywnego wyniku testÛw firmy wypuszczajπ wersje koÒcowe. Czasami jednak termin koÒcowy zostaje przekroczony z powodu duøej iloúci b≥ÍdÛw i nienadπøania zespo≥u naprawiajπcego je, dlatego udostÍpnia siÍ wersjÍ beta wπskiej grupie docelowych uøytkownikÛw, ktÛrzy zg≥aszajπ poprawki i uwagi, tak aby koÒcowy produkt mia≥ jak najmniej wad. CzÍstym przypadkiem po oficjalnym wydaniu gry jest znalezienie krytycznych b≥ÍdÛw przez koÒcowych uøytkownikÛw, dlatego szybkπ reakcjπ firmy musi byÊ wydanie patch'a~\footnote{dodatek do wydanej gry poprawiajπcy b≥Ídy lub dodajπcy nowe funkcje} poprawiajπcego go, poniewaø kaøda usterka moøe spowodowaÊ niekorzystny dla firmy spadek wizerunku oraz zainteresowania produktem.
\end{enumerate}


\section{Podstawowe pojÍcia dotyczπce wyúwietlania grafiki w 3D}
\label{Teoria:Pojecia}
Przed przejúciem do omawiania bibliotek programistycznych oraz procesu renderingu niezbÍdne jest wyjaúnienie najwaøniejszych pojÍÊ stosowanych w przekszta≥caniu i wyúwietlaniu grafiki 3D.
\subsection{Wektor}
\label{Teoria:Pojecia:Wektor}
Wektory w grafice 3D majπ dwa zastosowania. Pierwszym jest reprezentacja punktu w przestrzeni. Przyk≥adowo na dwuwymiarowej osi liczbowej punkt ma wspÛ≥rzÍdne $x=2.5$ i $x=-5$. Wektor reprezentujπcy pozycjÍ wyglπda nastÍpujπco: $\vec{pos} = (2.5, -5)$. W grafice trÛjwymiarowej dodatkowπ osiπ jest g≥Íbia (oú Z). Przyjmujπc $z=12$, przyk≥adowy wektor otrzymuje postaÊ: $\vec{pos} = (2.5, -5, 12)$.\\

Drugim zastosowaniem wektorÛw jest identyfikacja kierunku. Wektor taki ma postaÊ linii w uk≥adzie wspÛ≥rzÍdnych o zdefiniowanym punkcie poczπtkowym (startu) i koÒcowym (koÒca) wizualnie zakoÒczonym strza≥kπ. Mimo, øe poczπtek wektora nie musi znajdowaÊ siÍ w poczπtku uk≥adu wspÛ≥rzÍdnych, znaczπco u≥atwia to wszelkie operacje i obliczenia, poniewaø w tym wypadku wystarczπ jedynie wspÛ≥rzÍdne punktu koÒcowego, ktÛry okreúla kierunek wektora.\\

OprÛcz standardowych operacji dodawania, odejmowania i mnoøenia wektorÛw, wyrÛøniamy w grafice komputerowej trzy szczegÛlne dzia≥ania:
\begin{enumerate}
    \item \textbf{Normalizacja} -- Znormalizowany wektor otrzymuje siÍ przez podzielenie wszystkich elementÛw wektora przez jego d≥ugoúÊ. Otrzymany wektor ma ten sam kierunek, zwrot i d≥ugoúÊ rÛwnπ 1. U≥atwia to obliczenia i uniezaleønia wynik od d≥ugoúci wektorÛw.
    \item \textbf{Iloczyn skalarny} -- Operacja najczÍúciej stosowana w obliczeniach grafiki komputerowej. 
$$
\vec{a} \circ \vec{b} = \vec{a} \cdot \vec{b} \cdot cos\alpha
$$
DziÍki powyøszemu rÛwnaniu moøna otrzymaÊ kπt $\alpha$ miÍdzy dwoma znormalizowanymi wektorami. Przydaje siÍ on najczÍúciej do obliczania natÍøenia úwiat≥a padajπcego na element.
    \item \textbf{Iloczyn wektorowy} -- Wynikiem iloczynu wektorowego jest wektor prostopad≥y do dwÛch podanych wektorÛw. Przyk≥adowy wynik tej operacji jest pokazany na rysunku \ref{img:iloczyn}
%http://help.adobe.com/pl_PL/AS3LCR/Flash_10.0/flash/geom/Vector3D.html
\begin{figure}[h]
\centering
\includegraphics[width=60mm]{img/crossproduct.jpg}
\caption{Iloczyn wektorowy}
\label{img:iloczyn}
\end{figure}
\end{enumerate}

\subsection{Macierz}
\label{Teoria:Pojecia:Macierz}
\begin{equation}
M = \begin{bmatrix} M_{11}&M_{12}&M_{13}\\ M_{21}&M_{22}&M_{23}\\ M_{31}&M_{32}&M_{33} \end{bmatrix}
\end{equation}

Macierz, w przeciwieÒstwie do wektora (tablicy jednowymiarowej), jest tablicπ wielowymiarowπ. Do jej elementÛw moøna siÍ odwo≥ywaÊ poprzez podanie numeru wiersza oraz kolumny. \\

W grafice komputerowej najwaøniejszπ rolπ macierzy sπ przekszta≥cenia. Operacje translacji, rotacji i skalowania za pomocπ macierzy zostanπ dok≥adnie omÛwione w rozdziale \ref{Teoria:Rendering:Przeksztalcanie} poúwiÍconemu procesowi renderingu.

\subsection{Kwaternion}
\label{Teoria:Pojecia:Quaternion}
Kwaternion~\footnote{ang: Quaternion} to wektor czteroelementowy, ktÛrego pierwsze trzy elementy oznaczajπ oú, a czwarty wartoúÊ obrotu wyraøonego w radianach wed≥ug danej osi. \\

W grafice komputerowej kwaterniony znaczπco u≥atwiajπ obracanie elementÛw, g≥Ûwnie dziÍki operacji kompozycji: 
$$Q_w = Q_1 \cdot Q_2$$
Dla $Q_1 = (x_1, y_1, z_1, \alpha)$ i $Q_2 = (x_2, y_2, z_2, \beta)$, $Q_w$ oznacza obrÛt wokÛ≥ osi $x_1, y_1, z_1$ o kπt $\alpha$, a nastÍpnie wokÛ≥ osi $x_2, y_2, z_2$ o kπt $\beta$. \\

Drugπ waønπ operacjπ jest interpolacja, dziÍki ktÛrej mamy moøliwoúÊ obliczania poúrednich wartoúci obrotÛw w danym czasie. Umoøliwia ona tworzenie p≥ynnych animacji np. kamery.

\subsection{Wierzcho≥ek}
\label{Teoria:Pojecia:Wierzcholek}
Wierzcho≥ek~\footnote{ang: Vertex} jest to punkt w przestrzeni 3D zawierajπcy pozycjÍ jednego punktu. Dwa wierzcho≥ki ≥πczπ siÍ w krawÍdü, a trzy krawÍdzie w trÛjkπt - podstawowy budulec modeli trÛjwymiarowych. Wierzcho≥ki mogπ zawieraÊ dodatkowe informacje wymagane przy procesie renderingu takie jak:
\begin{itemize}
    \item \textbf{Koordynaty UV} -- Okreúlajπ wspÛ≥rzÍdne punktu na p≥aszczyünie tekstury
    \item \textbf{Wektor normalny} -- Wektor prostopad≥y do powierzchni trÛjkπta
    \item \textbf{Kolor} -- Kolor wierzcho≥ka
    \item \textbf{Tangent i binormal} -- Wartoúci przydatne przy efektach takich jak mapowanie wypuk≥oúci
\end{itemize}

\section{Technologia DirectX}
\label{Teoria:Directx}
Rozdzia≥ przedstawia technologiÍ Microsoft DirectX, jej historiÍ oraz podzia≥ na g≥Ûwne elementy.

\subsection{Historia}
\label{Teoria:Directx:Historia}
DirectX jest zestawem bibliotek wspomagajπcych generowanie grafiki dwu i trÛjwymiarowej. Pierwotnie dostÍpna by≥a biblioteka WinG, ktÛra rozszerza≥a moøliwoúci WinAPI~\footnote{Application Programming Interface}, jednak brak bezpoúredniego dostÍpu do warstwy sprzÍtowej bardzo ogranicza≥ Ûwczesne programowanie gier. \\

Pierwsze wydanie pojawi≥o siÍ w roku 1995 wraz z wydaniem systemu operacyjnego Windows~95. G≥Ûwnπ rÛønicπ miÍdzy WinG a bibliotekπ DirectX by≥ bezpoúredni dostÍp do warstwy sprzÍtowej, dziÍki czemu programiúci nie musieli juø tworzyÊ w≥asnych systemÛw generowania i wyúwietlania grafiki 3D tylko mogli skupiÊ siÍ na logice aplikacji. \\

Wraz z nowymi wersjami bibliotek rozszerzane by≥y one o nowe moøliwoúci i funkcje, jednak dopiero wersje 6.1 i 7 wydane w 1999 roku udostÍpni≥y obs≥ugÍ potokÛw renderujπcych. Wersja 8.0 wprowadzi≥a programowalny model przetwarzania - Vertex i Pixel Shader. DziÍki temu programista mÛg≥ zaprogramowaÊ w jÍzyku podobnym do asemblera sposÛb wykonywania obliczeÒ na wierzcho≥kach i pikselach bezpoúrednio na karcie graficznej.\\ 

Ostatniπ wersjπ przeznaczonπ dla systemu Windows XP jest DirectX 9.0c, w ktÛrej do pisania shaderÛw zosta≥ przygotowany jÍzyk HLSL~\footnote{High Level Shader Language} ze sk≥adniπ zbliøonπ do jÍzyka C. Za pomocπ tego narzÍdzia moøliwe sta≥o siÍ tworzenie efektÛw niemoøliwych do wykonania za pomocπ standardowych procedur.\\

Wraz z premierπ systemu Windows Vista zosta≥a udostÍpniona nowa wersja biblioteki DirectX oznaczona numerem 10.0. G≥Ûwnπ cechπ, ktÛra odrÛønia jπ od poprzednich wersji jest brak kompatybilnoúci wstecz. Powodem jest przepisanie ca≥ej biblioteki na nowo, dziÍki czemu zoptymalizowano kod i przystosowano tylko do najnowszych kart graficznych. Zmniejszono teø narzut interfejsu API na proces tworzenia grafiki, czyli moc obliczeniowπ CPU~\footnote{Central Processing Unit - Procesor}, ktÛry wykorzystywa≥ oko≥o 40\% cykli w wersji 9.0c, do 20\% w wersji 10.0. DziÍki temu g≥Ûwna jednostka obliczeniowa zyska≥a wiÍcej czasu na zaawansowane obliczenia AI~\footnote{Artificial intelligence - Sztuczna inteligencja} lub odwzorowywanie fizyki.\\

Z powodÛw ograniczeÒ sprzÍtowych autor w dalszej czÍúci pracy oraz projekcie bÍdzie opieraÊ siÍ na wersji 9.0c.\\

DirectX jest komponentem, ktÛry stanowi wspÛlne úrodowisko dla czterech g≥Ûwnych us≥ug: graphics, input, audio i play.
\subsection{DirectX Graphics}
\label{Teoria:Directx:Graphics}
DirectDraw jest czÍúciπ DirectX odpowiedzialnπ za wyúwietlanie grafiki 2D. Z powodu dynamicznego rozwoju grafiki 3D, zosta≥ on po≥πczony z Direct3D tworzπc wspÛlny pakiet DirectX Graphics.\\

Dirct3D odpowiada za wyúwietlanie grafiki trÛjwymiarowej. Umoøliwia wykorzystywanie akceleracji sprzÍtowej oraz zaawansowanych moøliwoúci kart graficznych:
\begin{itemize}
    \item \textbf{Obs≥uga i filtrowanie tekstur} -- Przyk≥adowa technika o nazwie MipMapping (dok≥adniejszy opis w rozdziale \ref{Teoria:Techniki:Teksturowanie:Filtrowanie}) umoøliwia poprawÍ jakoúci wyúwietlanej tekstury w zaleønoúci od odleg≥oúci wyúwietlanego obiektu od pozycji kamery
    \item \textbf{Z-Bufor} -- Przechowywanie informacji odnoúnie odleg≥oúci (g≥Íbi) wyúwietlanych pikseli
    \item \textbf{Oúwietlenie} -- Wbudowana obs≥uga cieniowania p≥askiego oraz Gouraud'a (wiÍcej o oúwietleniu w rozdziale \ref{Teoria:Techniki:Oswietlenie})
    \item \textbf{Alfa blending} --Technika pozwalajπca na tworzenie przezroczystych obiektÛw
    \item \textbf{Anti-aliasing} -- Poprawianie jakoúci obrazu
    \item \textbf{Vertex/Pixel shaders} -- Obs≥uga shaderÛw
    \item ... i wiele innych
\end{itemize}

DirectX Graphics wspomaga pisanie aplikacji graficznych nie tylko na platformy Windows, ale rÛwnieø konsole Xbox i Xbox 360 firmy Microsoft.

\subsection{DirectX Input}
\label{Teoria:Directx:Input}
DirectX Input jest komponentem odpowiedzialnym za obs≥ugÍ urzπdzeÒ wejúciowych takich jak mysz, klawiatura czy urzπdzenia przystosowane do gier typu joystick, gamepad itp. Moøe on pracowaÊ w dwÛch trybach:
\begin{enumerate}
    \item \textbf{Bezpoúredni} -- W tym trybie odczytywany jest aktualny stan wejúciowy. Jest on najszybszy, jednak niesie za sobπ powaønπ wadÍ: miÍdzy dwoma odczytami stan urzπdzenia moøe siÍ zmieniÊ wielokrotnie (np. wciúniÍcie i zwolnienie klawisza), przez co taka operacja zostanie pominiÍta.
    \item \textbf{Buforowany} -- Uzupe≥nia tryb bezpoúredni o buforowanie zmian stanu urzπdzenia, dziÍki czemu kaøda zmiana zostanie zarejestrowana i moøe zostaÊ obs≥uøona. Jest to najdok≥adniejsza metoda, dlatego jest najczÍúciej wykorzystywana w grach komputerowych.
\end{enumerate}

Ogromnπ zaletπ biblioteki DirectX Input jest tzw. Action Mapping umoøliwiajπcy przypisanie akcji do konkretnych przyciskÛw. DziÍki takiemu rozwiπzaniu po przypisaniu konkretnej akcji, np. ruch do przodu strza≥ce na klawiaturze i przyciskowi "w gÛrÍ" na gamepadzie, w aplikacji otrzymujemy komunikat wystπpienia danej akcji - niezaleønie od tego jakie urzπdzenie jπ wygenerowa≥o. 

\subsection{DirectX Audio}
\label{Teoria:Directx:Audio}
G≥Ûwnym elementem DirectX Audio jest biblioteka DirectSound, umoøliwiajπca szybki dostÍp do karty düwiÍkowej i odtwarzanie/nagrywanie düwiÍkÛw. Dodatek DirectSound3D zapewnia obs≥ugÍ düwiÍku trÛjwymiarowego.\\

DirectMusic, mimo øe wykorzystuje wewnÍtrznie DirectSound, jest duøo bardziej rozbudowanym komponentem umoøliwiajπcym odtwarzanie wielu formatÛw takich jak OGG i MP3.

\subsection{DirectX Play}
\label{Teoria:Directx:Play}
DirectPlay pozwala na tworzenie aplikacji i gier sieciowych. Umoøliwia tworzenie dwÛch typÛw sieci:
\begin{enumerate}
    \item \textbf{Klient-Serwer} -- SieÊ w ktÛrej zarzπdzaniem po≥πczeniami i obs≥ugπ klientÛw zajmuje siÍ serwer. Informacje wysy≥ane z urzπdzeÒ klienckich trafiajπ najpierw do serwera, ktÛry nastÍpnie rozsy≥a danπ informacjÍ do wybranych lub wszystkich uczestnikÛw.
    \item \textbf{Peer to Peer} -- Komunikacja odbywa siÍ na zasadzie "kaødy z kaødym" czyli wysy≥ajπc informacjÍ trafia ona bezpoúrednio do wszystkich uczestnikÛw sieci.
\end{enumerate}

\section{Proces renderingu}
\label{Teoria:Rendering}
\subsection{WstÍp}
\label{Teoria:Rendering:Wstep}
Proces renderingu jest najbardziej skomplikowanym i czasoch≥onnym procesem podczas dzia≥ania gry, poniewaø musi siÍ on wykonywaÊ w czasie rzeczywistym i w ciπgu jednej sekundy wywo≥aÊ co najmniej 15-30 razy, aby zachowaÊ p≥ynnoúÊ wyúwietlanego obrazu. W dawnych czasach duøa czÍúÊ operacji by≥a wykonywana przez CPU przez co tworzenie zaawansowanych efektÛw by≥o bardzo czasoch≥onne i niemoøliwe w przypadku aplikacji czasu rzeczywistego. DziÍki dynamicznemu rozwojowi uk≥adÛw graficznych wiÍkszoúÊ obliczeÒ zosta≥a przeniesiona na procesory GPU karty graficznej. \\

Niniejszy rozdzia≥ ma na celu przedstawienie procesu renderowania jednej klatki obrazu, od przekszta≥cania wierzcho≥kÛw, przez teksturowanie i oúwietlenie, do post-processing'u gotowej klatki.

\subsection{Przekszta≥canie wierzcho≥kÛw}
\label{Teoria:Rendering:Przeksztalcanie}

\subsubsection{Macierz úwiata}
\label{Teoria:Rendering:Przeksztalcanie:Swiat}

Kaødy model reprezentowany jest przez wierzcho≥ki. Ich liczba mieúci siÍ w przedziale od kilku do nawet kilkuset tysiÍcy. Kaødy z nich ma ustalonπ pozycjÍ w lokalnym uk≥adzie wspÛ≥rzÍdnych, czyli wzglÍdem úrodka modelu. \\

Pierwszπ operacjπ jakπ naleøy wykonaÊ w celu wyúwietlenia modelu na ekranie jest transformacja kaødego wierzcho≥ka do wspÛlnego uk≥adu wspÛ≥rzÍdnych. Tworzy siÍ w tym celu macierz úwiata, przez ktÛrπ naleøy pomnoøyÊ pozycjÍ wierzcho≥ka. Poniewaø macierze o wymiarach 4x4 sπ standardem w obliczeniach, mnoøπc wektor naleøy dodaÊ do niego czwartπ pozycjÍ o wartoúci 1):

$$\vec{pos} = (x, y, z, 1)$$

WyrÛøniamy trzy podstawowe operacje przekszta≥cajπce: translacja, rotacja, skalowanie.

\begin{enumerate}
    \item \textbf{Translacja} -- OgÛlna postaÊ macierzy translacji na pozycjÍ $x_2$, $y_2$, $z_2$ jest nastÍpujπca:
\begin{equation}
M_{translation} = 
\begin{bmatrix} 
1&0&0&0\\
0&1&0&0\\
0&0&1&0\\
x_2&y_2&z_2&1
\end{bmatrix}
\end{equation}
Aby otrzymaÊ wektor $\vec{pos} = (5, 2, -3, 1)$ przesuniÍty wzglÍdem pozycji $x = 4$, $y = 3$, $z = 10$ naleøy wykonaÊ dzia≥anie:
\begin{equation}
\vec{posT} = [5,2,-3,1] \cdot 
\begin{bmatrix} 
1&0&0&0\\
0&1&0&0\\
0&0&1&0\\
4&3&10&1
\end{bmatrix}
\end{equation}
Wynikowπ pozycjπ sπ pierwsze trzy elementy wynikowego wektora.

    \item \textbf{Skalowanie} -- Macierz skalowania przez wartoúci $x_2$, $y_2$, $z_2$ wed≥ug odpowiednich osi X, Y i Z prezentuje siÍ nastÍpujπco:
\begin{equation}
M_{scale} = 
\begin{bmatrix} 
x_2&0&0&0\\
0&y_2&0&0\\
0&0&z_2&0\\
0&0&0&1
\end{bmatrix}
\end{equation}
Dzia≥anie w wyniku ktÛrego otrzymujemy przeskalowany wektor wyglπda identycznie jak w przypadku operacji translacji - naleøy przemnoøyÊ wektor przez macierz skalowania.
    \item \textbf{Rotacja} -- Macierz obrotu dla kaødej osi X, Y i Z jest inna:

\begin{itemize}
    \item WzglÍdem osi X:
\begin{equation}
M_{rotationX} = 
\begin{bmatrix} 
1&0&0&0\\
0&\cos\alpha&\sin\alpha&0\\
0&-\sin\alpha&\cos\alpha&0\\
0&0&0&1
\end{bmatrix}
\end{equation}
    \item WzglÍdem osi Y:
\begin{equation}
M_{rotationY} = 
\begin{bmatrix} 
\cos\alpha&0&-\sin\alpha&0\\
0&1&0&0\\
\sin\alpha&0&\cos\alpha&0\\
0&0&0&1
\end{bmatrix}
\end{equation}
    \item WzglÍdem osi Z:
\begin{equation}
M_{rotationZ} = 
\begin{bmatrix} 
\cos\alpha&\sin\alpha&0&0\\
-\sin\alpha&\cos\alpha&0&0\\
0&0&1&0\\
0&0&0&1
\end{bmatrix}
\end{equation}
\end{itemize}
\end{enumerate}

Mnoøπc odpowiednie macierze moøemy otrzymaÊ macierz, ktÛra jest po≥πczeniem kilku transformacji. Przyk≥adowo chcπc powiÍkszyÊ model dwukrotnie, nastÍpnie obrÛciÊ go wzglÍdem osi X o $25^{\circ}$ i Y o $125^{\circ}$ oraz przemieúciÊ wzglÍdem punktu $(5, 1, -2)$, naleøy stworzyÊ nastÍpujπcπ macierz úwiata:

\begin{equation}
M_{World} = 
\begin{bmatrix}
2&0&0&0\\
0&2&0&0\\
0&0&2&0\\
0&0&0&1
\end{bmatrix}
\cdot
\begin{bmatrix} 
1&0&0&0\\
0&\cos{(25^{\circ})}&\sin{(25^{\circ})}&0\\
0&-\sin{(25^{\circ})}&\cos{(25^{\circ})}&0\\
0&0&0&1
\end{bmatrix}
\cdot
\end{equation}

$$
\cdot
\begin{bmatrix} 
\cos{(125^{\circ})}&0&-\sin{(125^{\circ})}&0\\
0&1&0&0\\
\sin{(125^{\circ})}&0&\cos{(125^{\circ})}&0\\
0&0&0&1
\end{bmatrix}
\cdot
\begin{bmatrix} 
1&0&0&0\\
0&1&0&0\\
0&0&1&0\\
5&1&-2&1
\end{bmatrix}
$$
\begin{figure}[h]
\centering
\includegraphics{img/world1.jpg}
\caption{KolejnoúÊ mnoøenia: rotacja * translacja}
\label{img:world1}
\end{figure}
\begin{figure}[h]
\centering
\includegraphics{img/world2.jpg}
\caption{KolejnoúÊ mnoøenia: translacja * rotacja}
\label{img:world2}
\end{figure}

Waønym elementem jest kolejnoúÊ mnoøenia macierzy. Na rysunku \ref{img:world1} obiekt zosta≥ najpierw obrÛcony wzglÍdem poczπtku uk≥adu, a nastÍpnie przesuniÍty. Rysunek \ref{img:world2} pokazuje odwrotne mnoøenie: obiekt najpierw zosta≥ przesuniÍty, a nastÍpnie obrÛcony wzglÍdem poczπtku uk≥adu. Mimo, øe taka sytuacja najczÍúciej jest niepoøπdana, ma swoje zastosowanie w rysowaniu obiektÛw, ktÛrych pozycja zaleøy od innego obiektu. Dobrym przyk≥adem jest uk≥ad planet. Rysujπc ksiÍøyc ziemi najpierw obracamy go o pewien kπt, nastÍpnie przesuwamy w odpowiedniπ stronÍ od planety. Jako øe ziemia jest rÛwnieø obiektem, ktÛry krπøy wokÛ≥ s≥oÒca, ma swojπ macierz úwiata, przez ktÛrπ musimy pomnoøyÊ macierz ksiÍøyca. DziÍki temu pozycja ksiÍøyca zostaje przekszta≥cona wzglÍdem nowej pozycji ziemi.

\subsubsection{Macierz widoku}
\label{Teoria:Rendering:Przeksztalcanie:widok}
Kolejnym etapem jest przekszta≥cenie wierzcho≥kÛw z globalnej przestrzeni do przestrzeni obserwatora (kamery). W tym celu naleøy zbudowaÊ macierz widoku i pomnoøyÊ przez niπ macierz úwiata obiektu. PozycjÍ kamery okreúlajπ nastÍpujπce wektory:
\begin{itemize}
    \item $\vec{Pos}$ -- Pozycja kamery w globalnej przestrzeni
    \item $\vec{Up}$ -- Kierunek w gÛrÍ
    \item $\vec{Right}$ -- Kierunek w prawo
    \item $\vec{LookAt}$ -- Kierunek patrzenia kamery
\end{itemize}
Wektory $\vec{Up}$, $\vec{Right}$ i $\vec{LookAt}$ sπ znormalizowane i prostopad≥e do siebie. Majπc te dane moøna zbudowaÊ macierz (funkcja $Dot$ oblicza iloczyn skalarny miÍdzy dwoma wektorami):
\begin{equation}
M_{View} = 
\begin{bmatrix}
Right.x & Up.x & LookAt.x & 0\\
Right.y & Up.y & LookAt.y & 0\\
Right.z & Up.z & LookAt.z & 0\\
-Dot(Pos, Right) & -Dot(Pos, Up) & -Dot(Pos, LookAt) & 1
\end{bmatrix}
\end{equation}

\subsubsection{Macierz projekcji}
\label{Teoria:Rendering:Przeksztalcanie:projekcja}
%http://viz.aset.psu.edu/gho/sem_notes/color_3d/html/rendering.html
\begin{figure}[h]
\centering
\includegraphics[width=100mm]{img/frustrum.jpg}
\caption{Budowa bry≥y obcinania}
\label{img:frustrum1}
\end{figure}
Zadaniem macierzy projekcji jest przeniesienie obrazu trÛjwymiarowego na ekran dwuwymiarowy monitora zapewniajπc wraøenie trÛjwymiarowoúci (g≥Íbi) obiektÛw. Biblioteka DirectX umoøliwia stworzenie gotowej macierzy projekcji za pomocπ funkcji\\
\code{D3DXMatrixPerspectiveFovLH()}. Parametry jakie przyjmuje to:
\begin{enumerate}
    \item Kπt widzenia, najczÍúciej $45^{\circ}$
    \item Stosunek d≥ugoúci oraz szerokoúci ekranu
    \item Odleg≥oúÊ od obserwatora do Near~Clipping~Plane i Far~Clipping~Plane (patrz rys. \ref{img:frustrum1})
\end{enumerate}

Powsta≥a na obrazku \ref{img:frustrum1} bry≥a pokazuje nie tylko proces przekszta≥cania obrazu z 3D na 2D, ale rÛwnieø jest bry≥π obcinania tzn. wierzcho≥ki ktÛre wychodzπ poza niπ nie sπ uwzglÍdniane.

\subsection{Fixed-function/Programmable Pipeline}
W dawnych czasach (przed DirectX 8.0) dostÍpna by≥a jedynie ustalona kolejnoúÊ wykonywania operacji w procesie przekszta≥cania wierzcho≥kÛw na piksele przez kartÍ graficznπ (tzw. fixed-function pipeline):
\begin{enumerate}
    \item Przekszta≥cenie úwiata
    \item Przekszta≥cenie widoku
    \item Przekszta≥cenie projekcji
    \item Obcinanie~\footnote{ang: Culling}
\end{enumerate}
Macierze podawa≥o siÍ poprzez odpowiednie wywo≥ania funkcji. Wszelkie modyfikacje i efekty musia≥y byÊ umieszczane w kodzie aplikacji, przez co modyfikacja pojedynczych wierzcho≥kÛw by≥a niemoøliwa. åwiat≥a oraz teksturowanie rÛwnieø by≥y ograniczone do moøliwoúci uøywanej biblioteki. \\

Wraz z wprowadzeniem z wersjπ 8.0 programowalnego vertex shadera to ograniczenie zniknÍ≥o. Programista zyska≥ pe≥nπ kontrolÍ nad procesem przekszta≥cania wierzcho≥kÛw przy pomocy ma≥ych programÛw zwanych shaderami uruchamianych na procesorach vertex~shader na karcie graficznej. Takich procesorÛw jest przewaønie od kilku do kilkunastu, dziÍki czemu karta graficzna moøe rÛwnolegle wykonywaÊ obliczenia zmniejszajπc tym samym czas potrzebny na wygenerowanie klatki. \\

Pierwsza wersja udostÍpnia≥a doúÊ skomplikowany i niewygodny jÍzyk przypominajπcy asemblera. Dopiero w wersji 9.0 wprowadzono jÍzyk HLSL, ktÛry sk≥adniπ przypomina jÍzyk C. Program wykonuje siÍ dla kaødego wierzcho≥ka przyjmujπc na wejúcie informacje takie jak pozycja, koordynaty tekstury czy wektor normalny, a nastÍpnie zwraca przekszta≥conπ pozycjÍ oraz inne informacje, ktÛre s≥uøπ w kolejnych krokach renderingu.
Przyk≥adowy kod wykonujπcy przekszta≥cenie jednego wierzcho≥ka zosta≥ zamieszczony poniøej.

\begin{lstlisting}[language=C,caption={Przykladowy Vertex Shader}]
float4x4 WVP;
float4x4 World;
float4x4 View;
float4x4 Projection;
struct VS_Input{
	float4 Pos		: POSITION;
	float3 Normal	: NORMAL0;
	float2 Tex0		: TEXCOORD0;
};
struct VS_Output{
	float4  Pos     : POSITION;
	float2  Tex0    : TEXCOORD0;
	float3 Normal   : TEXCOORD1;
};
VS_Output VertexShader(VS_Input In){
	VS_Output Out = (VS_Output) 0;
	Out.Pos		=	mul(In.Pos,WVP);
	Out.Tex0	=	In.Tex0;
	Out.Normal  =   mul(float4(In.Normal, 1),World);
	return Out;
}
technique Sample{
	pass P0{
		VertexShader = compile vs_2_0 VertexShader();
	}
}
\end{lstlisting}

Powyøszy kod wskazuje wyraünie na pe≥nπ kontrolÍ i swobodÍ w wykonywaniu operacji, dziÍki czemu moøliwe jest implementowanie interesujπcych efektÛw takich jak deformacja obiektu w czasie rzeczywistym.

\subsection{Rasteryzacja}
\label{Teoria:Rendering:Rasteryzacja}
G≥Ûwnym celem procesu rasteryzacji jest jak najwierniejsze przedstawienie p≥askiej figury na urzπdzeniu rastorowym dysponujπcym ograniczonπ rozdzielczoúciπ (iloúciπ pikseli na ekranie). Rasteryzator przygotowuje dane dla kolejnego etapu renderingu: pixel shadera. Na zasadzie interpolacji liniowej opartej na informacjach o wierzcho≥kach trÛjkπta generuje pozycjÍ, kolor, koordynaty tekstury, i inne wartoúci, ktÛre nastÍpnie sπ przekazywane do programu obliczajπcego wynikowy kolor kaødego pixela.
%http://code.google.com/intl/pl-PL/apis/o3d/docs/programmablepipeline.html
\begin{figure}[h]
\centering
\includegraphics{img/rasteryzacja1.jpg} %[width=100mm]
\caption{TrÛjkπt przed rasteryzacjπ}
\label{img:rasteryzacja1}
\end{figure}
Rysunek \ref{img:rasteryzacja1} pokazuje trÛjkπt z≥oøony z trzech wierzcho≥kÛw, w ktÛrych zapisana jest informacja o pozycji, wektorze normalnym i kolorze.
\begin{figure}[h]
\centering
\includegraphics{img/rasteryzacja2.jpg} %[width=100mm]
\caption{TrÛjkπt i wyznaczone piksele po procesie rasteryzacji}
\label{img:rasteryzacja2}
\end{figure}
Po procesie rasteryzacji na rysunku \ref{img:rasteryzacja2} pokazane sπ wyznaczone piksele wewnπtrz trÛjkπta. Kaødemu z nich przypisana jest interpolowana wartoúÊ kaødej sk≥adowej wierzcho≥ka.

\subsection{Pixel shader}
\label{Teoria:Rendering:Pixel}
Pixel shader, podobnie jak vertex shader, jest procesorem na karcie graficznej. O ile vertex shader operuje na pojedynczych wierzcho≥kach, pixel shader zajmuje siÍ wyliczeniem koÒcowego koloru dla kaødego piksela na ekranie. Program pixel shader przyjmuje na wejúcie wartoúci wyliczone podczas etapu rasteryzacji i na ich podstawie wylicza koÒcowy kolor uøywajπc wartoúci koloru przekazanego na wejúcie lub mapujπc kolor tekstury za pomocπ przekazanych koordynatÛw UV.



\begin{lstlisting}[language=C,caption={Przykladowy Pixel Shader}] %,stepnumber=1,tabsize=1

(...)
struct VS_Output{
	float4  Pos     : POSITION;
	float2  Color    : COLOR;
	float3 Normal   : TEXCOORD0;
};
struct PS_Output{
	float4 Color : COLOR;
};
VS_Output VertexShader(VS_Input In){
	(...) /* Przekszta≥cenie wierzcho≥kÛw */
}
PS_Output PixelShader(VS_Output In){
	PS_Output Out = (PS_Output) 0;
	Out.Color = In.Color;
}
technique Sample{
	pass P0{
		VertexShader = compile vs_2_0 VertexShader();
		PixelShader  = compile ps_2_0 PixelShader();
	}
}
\end{lstlisting}
Pixel shader dziÍki pe≥nej kontroli nad wyliczaniem wynikowego koloru daje moøliwoúÊ implementacji oúwietlenia, teksturowania, i wielu innych zaawansowanych technik.

\subsection{Post-Processing}
\label{Label:Rendering:postprocessing}
Ostatnim elementem, aczkolwiek nieobowiπzkowym, wystÍpujπcym w procesie renderingu sπ efekty nak≥adane na obraz po wyrenderowaniu klatki wideo. Zapisujπc wygenerowany obraz do tekstury, moøemy na≥oøyÊ na niego rÛøne filtry zaimplementowane za pomocπ kolejnego wywo≥ania programu pixel shader. Taki shader przyjmuje na wejúcie koordynaty tekstury dla kaødego piksela i zwraca nowy obliczony kolor.
\begin{figure}[h]
\centering
\includegraphics[width=150mm]{img/post.jpg}
\caption{Przyk≥adowe filtry post-processing'owe}
\label{img:post}
\end{figure}
Rysunek \ref{img:post} pokazuje przyk≥adowe dzia≥anie filtrÛw. Na pierwsze dwa zdjÍcia zosta≥ na≥oøony filtr \mbox{rozmazujπcy/rozmywajπcy}. Dwa pozosta≥e to efekt starego uszkodzonego filmu oraz efekt sepii.

\subsection{Optymalizacja}
\label{Label:Rendering:optymalizacja}
WspÛ≥czesne karty graficzne pozwalajπ na wykonanie wszystkich opisanych powyøej czynnoúci w odpowiednim czasie. Czasem jednak ta moc nie wystarcza, dlatego istotnym elementem procesu renderingu obrazu sπ techniki optymalizacyjne. Autor prezentuje poniøej dwie z nich: Frustrum Culling oraz Occlusion Culling.

\subsubsection{Frustrum Culling}
\label{Label:Rendering:optymalizacja:frustrum}
Frustrum Culling to technika obcinania bry≥π widzenia. Jest wykonywana w kodzie aplikacji, jeszcze przed rozpoczÍciem procesu renderingu. Pierwszym etapem jest okreúlenie p≥aszczyzn budujπcych bry≥Í widzenia powsta≥π podczas tworzenia macierzy projekcji.

\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/frustrum2.jpg}
\caption{Budowa bry≥y obcinania}
\label{img:frustrum2}
\end{figure}

Przed renderowaniem obiektu naleøy sprawdziÊ czy zawiera siÍ on wewnπtrz powsta≥ej figury (lub przecina jπ). Poniewaø sprawdzanie prawdziwych modeli by≥oby bardzo nieefektywne, dla kaødego tworzy siÍ bry≥Í otaczajπcπ: szeúcian lub kulÍ. 

\begin{figure}[h]
\centering
\includegraphics[width=90mm]{img/frustrum3.jpg}
\caption{Wykrywanie widocznych obiektÛw}
\label{img:frustrum3}
\end{figure}

Na rysunku \ref{img:frustrum3} pokazano 3 obiekty podlegajπce sprawdzeniu. Model maskotki w ca≥oúci zawiera siÍ w bryle. Szeúcian otaczajπcy stoøek przecina przedniπ p≥aszczyznÍ bry≥y widzenia, wiÍc rÛwnieø zostanie wyúwietlony. Pi≥ka natomiast jest poza zasiÍgiem widzenia i zostanie odrzucona.

\subsubsection{Occlusion Culling}
\label{Label:Rendering:optymalizacja:occlusion}
Frustrum culling daje zadowalajπcy efekt w postaci odrzucenia wiÍkszoúci otaczajπcych efektÛw. Istniejπ jednak sytuacje, w ktÛrych to nie wystarcza. Prostym przyk≥adem jest scena, na ktÛrej przed kamerπ stoi duøy dom, a za nim ciπgnie siÍ pasmo drzew, budynkÛw i innych szczegÛ≥owych obiektÛw. Renderowanie ich zajÍ≥o by duøo czasu, podczas gdy na wynikowym obrazie nie by≥yby widoczne. Rozwiπzaniem tego problemu jest Occlusion Culling, czyli obcinanie niewidocznych obiektÛw. Aby tego dokonaÊ naleøy wyrenderowaÊ bry≥y otaczajπce do tymczasowego obrazu, a nastÍpnie sprawdziÊ iloúÊ widocznych pikseli kaødego obiektu. Jeúli ich suma wynosi zero, obiekt moøna wy≥πczyÊ z procesu renderingu. Rysunek \ref{img:culling} przedstawia scenÍ przed i po obcinaniu.
\begin{figure}[h]
\centering
\includegraphics[width=150mm]{img/culling.jpg}
\caption{A: Frustrum Culling, B: Occlusion Culling}
\label{img:culling}
\end{figure}

\section{Techniki wyúwietlania obrazu}
\label{Teoria:Techniki}
Niniejszy rozdzia≥ przedstawia techniki uatrakcyjniajπce wyúwietlanie obrazu. Pierwszπ z nich jest obs≥uga úwiate≥ w przestrzeni 3D i ich nak≥adanie na powierzchniÍ modelu. Zostanπ opisane trzy podstawowe metody cieniowania, jak i rÛøne typy ürÛde≥ úwiat≥a. Drugim etapem jest nak≥adanie tekstury oraz przedstawienie informacji dotyczπcych filtrowania tekstur i efektu mapowania wypuk≥oúci.

\subsection{Oúwietlenie}
\label{Teoria:Techniki:Oswietlenie}
\subsubsection{WstÍp}
\label{Teoria:Techniki:Oswietlenie:Wstep}
Najwaøniejszym zadaniem programistÛw grafiki jest zapewnienie jak najwiÍkszego realizmu prezentowanego obrazu. Aby to zapewniÊ implementuje siÍ modele oúwietlenia. Zaawansowane techniki úwietlne takie jak raytracing~\footnote{Metoda úledzenia promieni} sπ zbyt z≥oøone obliczeniowo, aby moøna je by≥o stosowaÊ w aplikacjach czasu rzeczywistego. W grach komputerowych najczÍúciej stosuje siÍ metody cieniowania: p≥askie, Gouranda i Phonga. RÛøniπ siÍ one iloúciπ obliczeÒ, odpowiednio dla trÛjkπtÛw, wierzcho≥kÛw i pojedynczych pikseli.

\subsubsection{èrÛd≥a úwiat≥a}
\label{Teoria:Techniki:Oswietlenie:Zrodla}
WyrÛøniamy dwa typy ürÛde≥ úwiat≥a:
\begin{enumerate}
    \item \textbf{Otaczajπce} -- Obiekt jest oúwietlony ze wszystkich stron jednoczeúnie. åwiat≥o to nie posiada kierunku ani pozycji, jedynie kolor oraz natÍøenie z jakim pada na obiekt.
    \item \textbf{Kierunkowe} -- åwiat≥o posiadajπce okreúlony kierunek i pozycjÍ, choÊ czasami ma znaczenie tylko jedno z nich. Przyk≥adowe warianty:
\begin{itemize}
    \item ØarÛwka jest przyk≥adem úwiat≥a punktowego~\footnote{ang: point light} (rysunek \ref{img:point}). Posiada pozycjÍ oraz úwieci we wszystkie strony, dlatego kierunek moøe byÊ wyliczany dynamicznie jako wektor o poczπtku: pozycji úwiat≥a i koÒcu: pozycji obiektu.
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/point.jpg}
\caption{Point light}
\label{img:point}
\end{figure}
    \item Latarnia uliczna lub latarka w praktyce jest øarÛwkπ (úwiat≥o punktowe), ktÛre odbija siÍ od zwierciad≥a, kierujπc promieÒ úwiat≥a w okreúlonπ stronÍ. Obliczenia towarzyszπce temu zjawisku sπ zbyt czasoch≥onne w przypadku aplikacji czasu rzeczywistego, dlatego stosuje siÍ úwiat≥o reflektorowe (rysunek \ref{img:reflect}), ktÛre zawiera pozycjÍ i kierunek, a czasami teø kπt, ktÛry okreúla zakres úwiat≥a (jego granicÍ, po ktÛrej przekroczeniu na obiekt nie padajπ juø promienie).
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/reflect.jpg}
\caption{Reflect light}
\label{img:reflect}
\end{figure}
    \item S≥oÒce, mimo øe jest przyk≥adem úwiat≥a punktowego, w praktyce jest tak duøe, øe przyjmuje siÍ sta≥y kierunek padania promieni s≥onecznych, ignorujπc jego pozycjÍ. DziÍki temu kaødy obiekt oúwietlany jest pod takim samym kπtem.
\end{itemize}
\end{enumerate}

Majπc okreúlone ürÛd≥o úwiat≥a naleøy nim odpowiednio potraktowaÊ oúwietlany obiekt. Proces ten nazywamy cieniowaniem.

\subsubsection{Cieniowanie p≥askie}
\label{Teoria:Techniki:Oswietlenie:Plaskie}
Cieniowanie p≥askie to najprostsza metoda cieniowania. Polega na obliczeniu jasnoúci powierzchni jednego trÛjkπta w zaleønoúci od kπta zawartego miÍdzy wektorem normalnym danej powierzchni oraz wektorem úwiat≥a. Mimo øe obliczenia sπ szybkie, poniewaø sπ wykonywane raz dla kaødego trÛjkπta, nie dajπ satysfakcjonujπcych efektÛw. Powaønπ wadπ jest jeden odcieÒ kaødej úcianki i widoczne przejúcia (krawÍdzie) miÍdzy kolorami.

\subsubsection{Cieniowanie Gourauda}
\label{Teoria:Techniki:Oswietlenie:Gouraud}
W przeciwieÒstwie do cieniowania p≥askiego, cieniowanie Gourauda wymaga policzenia natÍøenia úwiat≥a dla trzech wierzcho≥kÛw kaødego trÛjkπta. NastÍpnie na zasadzie interpolacji liniowej wyliczane sπ wynikowe kolory pikseli, ktÛre miesza siÍ z w≥aúciwym kolorem fragmentu obiektu. DziÍki temu zyskuje siÍ p≥ynny obraz przejúcia miÍdzy kolorami.

\subsubsection{Cieniowanie Phonga}
\label{Teoria:Techniki:Oswietlenie:Phong}
Cieniowanie Phonga jest najlepszπ z trzech metod cieniowania, ale teø najbardziej z≥oøonπ obliczeniowo. O ile dwie poprzednie operowa≥y na \mbox{trÛjkπtach/wierzcho≥kach} (obliczenia wykonywane przez vertex shader), ta oblicza natÍøenie úwiat≥a wykorzystujπc interpolowany wektor normalny dla kaødego piksela (pixel shader). DziÍki temu otrzymujemy dok≥adne odwzorowanie efektÛw takich jak odbicie úwiat≥a, ktÛre w przypadku cieniowania Gouraud bywa zniekszta≥cone lub niewyraüne.\\

Rysunek \ref{img:cieniowanie} przedstawia wszystkie 3 metody cieniowania.
\begin{figure}[h]
\centering
\includegraphics[width=100mm]{img/shading.jpg}
\caption{Od lewej: cieniowanie p≥askie, Gourauda, Phonga}
\label{img:cieniowanie}
\end{figure}

\subsection{Teksturowanie}
\label{Teoria:Techniki:Teksturowanie}
\subsubsection{Nak≥adanie tekstur}
\label{Teoria:Techniki:Teksturowanie:Nakladanie}
Mimo, øe oúwietlenie daje pewnπ dawkÍ realizmu, dopiero teksturowanie zapewnia rzeczywisty wyglπd. Tekstura jest plikiem graficznym, ktÛry jest nak≥adany na model wed≥ug ustalonych na kaødym wierzcho≥ku koordynatÛw UV. Sπ to wspÛ≥rzÍdne X i Y tekstury, ktÛre mieszczπ siÍ w przedziale od 0 do 1, poczπwszy od punktu $(0,0)$ w lewym gÛrnym rogu i $(1,1)$ w prawym dolnym (rysunek \ref{img:textureuv}). W procesie rasteryzacji koordynaty sπ interpolowane, okreúlajπc ktÛre fragmenty tekstury przypadajπ na poszczegÛlne piksele.
\begin{figure}[h]
\centering
\includegraphics[width=80mm]{img/texture.jpg}
\caption{Uk≥ad koordynatÛw UV tekstury}
\label{img:textureuv}
\end{figure}

DziÍki wspÛ≥rzÍdnym tekstury dla bardzo z≥oøonych modeli moøna przygotowaÊ jednπ teksturÍ i za pomocπ odpowiednio ustawionych koordynatÛw "wyciπgaÊ" poszczegÛlne fragmenty z jednego pliku graficznego.

\subsubsection{Filtrowanie tekstur}
\label{Teoria:Techniki:Teksturowanie:Filtrowanie}
Rzadko siÍ zdarza, øe wielkoúÊ tekstury odpowiada dok≥adnej wielkoúci obiektu na ktÛry jest ona nak≥adana. W takim przypadku obraz trzeba powiÍkszyÊ lub pomniejszyÊ. Proces ten jest nazywany filtrowaniem.

Poniøej zosta≥y opisane 3 sposoby filtrowania:
\begin{enumerate}
    \item \textbf{Point (prÛbkowanie punktowe)} -- Jest to najprostsza metoda zmiany rozmiaru tekstury, jednak najmniej dok≥adna i najrzadziej uøywana. Obraz jest zwyczajnie rozciπgany lub zmniejszany. Przy zwiÍkszaniu np. czterokrotnym kaødy piksel tekstury zajmuje cztery teksele~\footnote{Najmniejszy punkt tekstury wyúwietlany na ekranie} tekstury wyjúciowej. Przy zmniejszaniu czterokrotnym zostaje brany pod uwagÍ co czwarty piksel. PrÛbkowanie punktowe czÍsto powoduje efekt pikselozy, czyli widoczne pojedyncze teksele tekstury i brak ≥agodnych przejúÊ miÍdzy nimi.
    \item \textbf{Linear (filtrowanie liniowe)} -- W tej metodzie podczas rozciπgania lub zmniejszania obrazu dla kaødego piksela obliczana jest úrednia z czterech przylegajπcych pikseli. DziÍki temu zyskuje siÍ ≥agodne przejúcie miÍdzy kolorami i nie wystÍpuje efekt pikselozy. Mniejsze obrazy stajπ siÍ rozmazane, jednak jest to lepszy efekt od ostrych w przypadku prÛbkowania punktowego.
    \item \textbf{MipMapping} -- Mipmapping to technika polegajπca na tworzeniu mniejszych lub wiÍkszych wersji tekstury w zaleønoúci od odleg≥oúci obiektu od obserwatora. Przyk≥adowo obiekt majπcy wymiary 13x15 wymaga tekstury o wymiarach 16x16, a wiÍkszy, ktÛrego wymiary to 34x54 potrzebuje tekstury 64x64. Dla obu przypadkÛw odwo≥ywanie siÍ do najwyøszej tekstury nie ma sensu, poniewaø spora czÍúÊ pikseli i tak nie zostanie wyúwietlona. Zaletπ mipmappingu jest wstÍpne usuwanie zak≥ÛceÒ skalowanych tekstur (np metodπ filtrowania liniowego) oraz zwiÍkszenie prÍdkoúci teksturowania. Wadπ jest wiÍksza iloúÊ pamiÍci potrzebnej do przechowywania skalowanych wersji tekstury. Mipmapping jest podstawπ dla dwÛch kolejnych metod filtrowania:
\begin{itemize}
    \item \textbf{TrÛjliniowe} -- Jest to rozszerzenie filtrowania liniowego, polegajπce na uwzglÍdnieniu mipmap oraz zamazywaniu granic miÍdzy nimi przez interpolacjÍ miÍdzy kolejnymi poziomami mniejszych lub wiÍkszych wersji tekstury w zaleønoúci od odleg≥oúci.
    \item \textbf{Anizotropowe} -- O ile filtrowanie trÛjliniowe jest z powodzeniem wykorzystywane w wiÍkszoúci przypadkÛw - nie sprawdza siÍ np. przy wyúwietlaniu oteksturowanego p≥askiego terenu ciπgnπcego siÍ wg≥πb ekranu. Filtrowanie anizotropowe rozwiπzuje ten problem uwzglÍdniajπc (oprÛcz pozycji) kπt patrzenia kamery. DziÍki temu filtrowanie jest intensywniejsze w g≥πb ekranu.
\end{itemize}
\end{enumerate}

\subsubsection{Mapowanie normalnych}
\label{Teoria:Techniki:Teksturowanie:Normalne}
Tworzenie bardzo szczegÛ≥owych modeli, mimo øe nadajπ one wiÍkszego realizmu grze, w wiÍkszoúci przypadkÛw jest k≥opotliwe, poniewaø znaczπco zwiÍkszajπ czas renderingu i utrudniajπ np. wykrywanie kolizji (lub nie sπ do tego wymagane). Mapowanie normalnych~\footnote{Normal Mapping} jest technikπ, ktÛra umoøliwia sztucznπ wizualizacjÍ wypuk≥oúci lub wklÍs≥oúci na powierzchni przy uøyciu odpowiedniej gry úwiate≥. Rysunek \ref{img:normalmapping} pokazuje dzia≥anie tego efektu. Obie kule sπ reprezentowane przez ten sam model. DziÍki technice mapowania normalnych na prawej zosta≥y sztucznie wymodelowane wypuk≥oúci.

\begin{figure}[h]
\centering
\includegraphics[width=80mm]{img/normalmapping.jpg}
\caption{Model przez i po mapowaniu}
\label{img:normalmapping}
\end{figure}

Technika ta polega na zastÍpowaniu wektorÛw normalnych prostopad≥ych do powierzchni wektorami zapisanymi na tzw. normal mapie, czyli pliku graficznym, ktÛrego kaøda sk≥adowa koloru RGB odpowiada wspÛ≥rzÍdnym nowego wektora normalnego. Naleøy zaznaczyÊ, øe cieniowanie obiektu musi odbywaÊ siÍ w pixel shaderze, w ktÛrym oprÛcz pobranego koloru tekstury pobiera siÍ kolor z normal mapy, a nastÍpnie wykorzystujπc nowy wektor wykonywane sπ pozosta≥e obliczenia.

\begin{figure}[h]
\centering
\includegraphics[width=80mm]{img/normalmapping2.jpg}
\caption{Przyk≥ad tekstury i normal mapy}
\label{img:normalmapping}
\end{figure}

\section{Fizyka w grach komputerowych - biblioteka PhysX}
\label{Teoria:Fizyka}
Niniejszy rozdzia≥ ma na celu przedstawienie silnika fizycznego PhysX firmy NVIDIA, s≥uøπcego do tworzenia úrodowiska fizycznego, zapewniajπcego grom komputerowym zbliøonej do rzeczywistoúci dynamiki obiektÛw.

\subsection{WstÍp}
\label{Teoria:Fizyka:Wstep}
Gry komputerowe z roku na rok stajπ siÍ ≥adniejsze, wykorzystujπ najnowsze moøliwoúci kart graficznych, zapewniajπc graczom jak najwierniejsze odwzorowanie rzeczywistego wyglπdu. Waønym elementem, obok grafiki, jest dynamika gry. Sk≥adajπ siÍ na niπ g≥Ûwnie:

\begin{itemize}
    \item \textbf{Sterowanie} -- SposÛb poruszania postaciπ
    \item \textbf{Dynamika obiektÛw} -- Dzia≥anie na obiekty si≥ fizycznych takich jak grawitacja, wiatr, tarcie itp.
    \item \textbf{Wykrywanie kolizji} -- Wykrywanie kolizji obiektÛw oraz odpowiednie reagowanie w przypadku wystπpienia zderzenia
\end{itemize}

Wszystkie te trzy elementy sprowadzajπ siÍ do implementacji praw fizyki w grach komputerowych. Dok≥adne odwzorowanie zjawisk fizycznych jest trudne i bardzo z≥oøone obliczeniowo. Dla kaødego obiektu posiadajπcego w≥asnoúci fizyczne takie jak masa i wielkoúÊ, w zaleønoúci od dzia≥ajπcych na niego si≥, naleøy obliczyÊ nowπ pozycjÍ, prÍdkoúÊ, kierunek, tarcie, oraz inne wymagane dla danego úrodowiska w≥aúciwoúci. Wymaga to wielu zaawansowanych obliczeÒ wykonywanych w czasie rzeczywistym.\\

W wiÍkszoúci przypadkÛw odpowiedzialnym za obliczenia fizyczne jest procesor CPU. Nie jest on wystarczajπco szybki aby dok≥adnie odwzorowaÊ úrodowisko fizyczne, dlatego stosuje siÍ uproszczenia wzorÛw, ktÛre znacznie przyúpieszajπ obliczenia i jednoczeúnie zmniejszajπ realizm dzia≥ania gry.\\

Technologia PhysX firmy NVIDIA przenosi obliczenia zwiπzane z fizykπ na jednostki obliczeniowe karty graficznej. Jest to wydajny silnik fizyczny pozwalajπcy na tworzenie wirtualnego úrodowiska i symulacjÍ zjawisk fizycznych dziÍki wielordzeniowym procesorom umieszczonym na karcie graficznej, zwiÍkszajπcy wyk≥adniczo moc obliczeniowπ potrzebnπ do przetwarzania fizyki.\\

Silnik fizyczny PhysX wykorzystujπc sprzÍtowπ akceleracjÍ karty graficznej umoøliwia modelowanie realistycznych zjawisk fizycznych takich jak:
\begin{itemize}
    \item Wybuchy i eksplozje razem z generowaniem dymu i szczπtek rozbitych elementÛw
    \item Ciecze, ktÛre posiadajπ gÍstoúÊ i objÍtoúÊ
    \item Efekty atmosferyczne takie jak realistyczna mg≥a, dym, deszcz, ktÛre wchodzπ w interakcje z otoczeniem
    \item Materia≥y, ktÛre reagujπ na wiatr i czynniki zewnÍtrzne (moøliwe np. rozdarcie materia≥u, deformacja)
    \item Dodatkowe wsparcie dla kÛ≥ pojazdÛw, pozwalajπce na tworzenie bardziej realistycznych symulacji samochodowych
    \item Zaawansowana obs≥uga kolizji, wraz z generowaniem zdarzeÒ
\end{itemize}

\subsection{Scena}
\label{Teoria:Fizyka:Scena}
Scena jest úrodowiskiem, w ktÛrym przeprowadzana jest symulacja fizyczna úrodowiska. Ustawia siÍ w niej parametry, miÍdzy innymi:
\begin{itemize}
    \item Grawitacja, najczÍúciej 9.8 m/s dla symulacji warunkÛw ziemskich.
    \item GruboúÊ skÛry obiektÛw, ktÛra jest ustawiana dla kaødego nowego obiektu sceny. Okreúla ona w jakim stopniu obiektu siÍ przenikajπ.
    \item Typ symulacji, czyli sposÛb w jaki PhysX bÍdzie dokonywaÊ obliczeÒ: sprzÍtowo (wykorzystany bÍdzie procesor karty graficznej) i programowo (uøycie procesora CPU).
\end{itemize}

\subsection{Aktorzy}
\label{Teoria:Fizyka:Aktorzy}
Aktorem okreúla siÍ obiekt fizyczny posiadajπcy w≥aúciwoúci fizyczne takie jak masa, kszta≥t, po≥oøenie, materia≥ z jakiego jest zbudowany itd. Aktorzy dzielπ siÍ na dwie grupy:
\begin{itemize}
    \item \textbf{Dynamiczni} -- Na obiekty dynamiczne dzia≥ajπ si≥y oraz sπ wykrywane miÍdzy nimi (a takøe miÍdzy obiektem dynamicznym i statycznym) kolizje. Przyk≥ady: pi≥ka, deska, samochÛd.
    \item \textbf{Statyczni} -- Sπ to obiekty ze sta≥π pozycjπ, kolizje miÍdzy nimi nie sπ wykrywane. Przyk≥ady: budynek, teren.
\end{itemize}

Pierwszym krokiem w celu stworzenia aktora jest okreúlenie materia≥u. Ustawia siÍ w nim miÍdzy innymi nastÍpujπce w≥asnoúci:
\begin{itemize}
    \item \textbf{Restitution (elastycznoúÊ)} -- Sk≥onnoúÊ obiektu do odbijania siÍ podczas kolizji.
    \item \textbf{Static Friction (tarcie statyczne)} -- SposÛb, w jaki obiekt zachowuje siÍ po dzia≥aniu na niego si≥π. Ustawienie wysokich wartoúci sprawia, øe obiekt bÍdzie bardziej sk≥onny do toczenia siÍ aniøeli do przesuwania.
    \item \textbf{Dynamic Friction (tarcie dynamiczne)} -- Okreúla opÛr, ktÛry stawia obiekt w momencie przesuwania po powierzchni. Wyøsza wartoúÊ powoduje wiÍksze zapotrzebowanie na si≥Í w trakcie przesuwania.
\end{itemize}

Kolejnym krokiem jest utworzenie kszta≥tu aktora. S≥uøy on do fizycznej reprezentacji obiektu w symulacji. Na podstawie kszta≥tÛw wykrywane sπ kolizje.

\begin{itemize}
    \item Prostopad≥oúcian, Kula i Kapsu≥a to podstawowe kszta≥ty. Z nich najczÍúciej buduje siÍ bardziej z≥oøone. Dla przyk≥adu z kilku kapsu≥ek moøna wymodelowaÊ rÍce, nogi i cia≥o cz≥owieka, natomiast do reprezentacji g≥owy uøyÊ boksa lub kuli.
    \item P≥aszczyzna reprezentuje p≥askπ przestrzeÒ. NajczÍúciej jest to "pod≥oga" symulacji, ktÛra oddziela czÍúÊ pustπ (dÛ≥) od pozosta≥ej, w ktÛrej znajdujπ siÍ obiekty.
    \item Convex Mesh s≥uøy do modelowania bardziej z≥oøonych obiektÛw, ktÛrych nie da siÍ w prosty sposÛb zbudowaÊ z wymienionych powyøej kszta≥tÛw. Mimo dowolnego wypuk≥ego kszta≥tu ma on ograniczenie do 256 poligonÛw.
\end{itemize}
Powyøsze kszta≥ty stosuje siÍ zarÛwno do dynamicznych jak i statycznych obiektÛw, poniewaø zachodzi miÍdzy nimi moøliwoúÊ wykrycia kolizji. Poniøsze stosuje siÍ do modelowania obiektÛw statycznych, poniewaø wykrycie miÍdzy nimi kolizji nie jest moøliwe:
\begin{itemize}
    \item Triangle Mesh pozwala na dok≥adnπ reprezentacjÍ modelu np. budynku.
    \item Heightfield jest zoptymalizowany pod kπtem reprezentacji terenu.
\end{itemize}

Po utworzeniu kszta≥tu obiektu i przypisaniu mu materia≥u naleøy ustawiÊ pozosta≥e w≥aúciwoúci obiektu takie jak: masa (lub gÍstoúÊ), pozycja oraz orientacja startowa.\\

\subsection{Wykrywanie kolizji}
\label{Teoria:Fizyka:Kolizje}
Sprawdzenie kolizji miÍdzy obiektami na zasadzie kaødy~z~kaødym przy duøych scenach by≥o by zbyt wymagajπce obliczeniowo, a takøe w wiÍkszoúci przypadkÛw niepotrzebne. PhysX optymalizuje to dzielπc úwiat na mniejsze przestrzenie, dziÍki temu kaødy obiekt jest sprawdzany pod kπtem wystπpienia kolizji jedynie z najbliøszymi obiektami w jego otoczeniu. \\

Po ustaleniu pary obiektÛw bÍdπcych dostatecznie blisko siebie nastÍpuje sprawdzenie typÛw obiektÛw (co najmniej jeden z nich musi byÊ dynamiczny), a nastÍpnie grup kolizyjnych, ktÛrymi uøytkownik moøe kontrolowaÊ wykrywanie kolizji miÍdzy okreúlonymi obiektami. \\

Po wykryciu kolizji generowane jest zdarzenie (raport), dziÍki ktÛremu programista moøe obs≥uøyÊ wystπpienie kolizji. Moøna rÛwnieø zdefiniowaÊ zdarzenia, ktÛre majπ byÊ raportowane. Przyk≥adowo jeúli chcemy aby PhysX poinformowa≥ nas tylko o uderzeniu obiektu w pod≥ogÍ, ustawiamy mu flagÍ \mbox{NX\_NOTIFY\_ON\_START\_TOUCH}. Pozosta≥e zdarzenia, takie jak przesuwanie lub oderwanie od pod≥ogi nie bÍdπ zg≥aszane.\\

Pewnπ odmianπ raportÛw kolizji sπ tak zwane \textbf{triggery}. Dzia≥ajπ one na zasadzie generowania informacji o wejúciu w przestrzeÒ okreúlonego obiektu, przebywaniu w niej oraz opuszczeniu. Obiektem takim moøe byÊ dowolny kszta≥t opisany w poprzednim rozdziale, zaznaczajπc, øe obs≥uga kolizji convex mesh i triangle mesh, oraz triangle mesh i triangle mesh, nie sπ obs≥ugiwane. Przyk≥adowym zastosowaniem triggerÛw jest tworzenie systemu automatycznego otwierania drzwi po wejúciu na schodek.

\subsection{Sterowanie obiektami}
\label{Teoria:Fizyka:Sterowanie}
Sterowanie obiektami rÛøni siÍ dla obiektÛw dynamicznych i statycznych.\\

Obiekty dynamiczne to cia≥a fizyczne, dla ktÛrych w trakcie dzia≥ania symulacji nie moøna bezpoúrednio zmieniÊ pozycji ani orientacji. Dzia≥ajπ na nie si≥y fizyczne, dlatego sterowanie polega g≥Ûwnie na nadawaniu im si≥ z dowolnego punktu i w dowolnym kierunku. Przyk≥adem takiego rozwiπzania jest toczenie kuli. Poczπtek si≥y zaczepiony jest w úrodku obiektu, natomiast koniec skierowany jest w stronÍ, w ktÛrπ kula ma siÍ przetoczyÊ. Wartym dodania jest fakt, øe si≥Í moøna zaczepiÊ nie tylko w lokalnym uk≥adzie obiektu, ale teø w globalnych wspÛ≥rzÍdnych úwiata. \\

Obiekty statyczne to obiekty na ktÛre nie dzia≥ajπ øadne si≥y. Daje to moøliwoúÊ dynamicznej zmiany pozycji i orientacji aktora poprzez odpowiednie wywo≥ania funkcji. To rozwiπzanie stosuje siÍ do kierowania postaciami, ktÛre przez ca≥y czas zachowujπ pionowπ postawÍ, lub w przypadku gier FPP~{First Person Perspective}, w ktÛrych poruszamy siÍ po úwiecie oglπdajπc go oczami bohatera (sterujπc kamerπ). RÍczna implementacja takiego zachowania jest moøliwa, jednak wiπøe siÍ z wieloma trudnoúciami. PhysX wychodzπc na przeciw zapotrzebowaniu udostÍpnia narzÍdzie, ktÛre to u≥atwia, czyli Character~Controler. Pozwala on na stworzenie obiektu, ktÛry moøna w prosty sposÛb poruszaÊ. UdostÍpnia rÛwnieø dwie w≥aúciwoúci, ktÛre okreúlajπ moøliwoúci przemieszczania siÍ obiektu na danym terenie:
\begin{itemize}
    \item \textbf{Auto Stepping} -- Umoøliwia ustawienie rÛønicy w wysokoúci wybojÛw, ktÛre obiekt pokona bez problemu, a na ktÛrych siÍ zatrzyma. Przyk≥adem sπ schody, ktÛre postaÊ powinna pokonaÊ automatycznie, oraz wysoki podest, na ktÛry trzeba wskoczyÊ.
    \item \textbf{Walkable Parts} -- Domyúlnie obiekt moøna przemieúciÊ gdziekolwiek. Nie jest to zgodne z rzeczywistoúciπ. Ta opcja pozwala na ustalenie limitu pochy≥oúci w kπtach, do ktÛrego obiekt moøe swobodnie poruszaÊ siÍ, a po przekroczeniu dalsze sterowanie w danym kierunku staje siÍ niemoøliwe. Przyk≥adem jest gÛrzysty i wyboisty teren. PostaÊ porusza siÍ swobodnie po pochy≥ych wzniesieniach, ktÛrych kπt jest mniejszy od 45 stopni.
\end{itemize}

\subsection{Debugowanie symulacji}
\label{Teoria:Fizyka:debug}
PhysX Visual Debugger jest narzÍdziem, ktÛre nie tylko pozwala na kontrolowanie symulacji fizycznej, ale takøe pomaga w przypadku rozwiπzywania problemÛw. G≥Ûwne zalety PVD:
\begin{itemize}
    \item Wizualizacja wszystkich obiektÛw na scenie, si≥, kolizji, pÛl si≥owych i innych
    \item Kontrolowanie obiektÛw oraz si≥ dzia≥ajπcych na nie za pomocπ lewego przycisku myszki
    \item DostÍp do wszystkich informacji i w≥aúciwoúci kaødego obiektu
    \item Swobodna kamera umoøliwiajπca podglπd sceny pod rÛønym kπtem
\end{itemize}

\begin{figure}[h]
\centering
\includegraphics[width=100mm]{img/physxDebugger.jpg}
\caption{Podglπd sceny w programie PhysX Visual Debugger}
\label{img:normalmapping}
\end{figure}

\subsection{Podsumowanie}
\label{Teoria:Fizyka:podsumowanie}
Fizyka jest niemaløe obowiπzkowym elementem kaødej gry. Jak najwierniejsze odwzorowanie zjawisk fizycznych jest nie tylko przyjemne dla oka, ale rÛwnieø odczuwalne podczas sterowania g≥Ûwnym obiektem gry. Technologia NVIDIA PhysX pozwala twÛrcom gier na stworzenie wydajnego úrodowiska fizycznego, dziÍki czemu mogπ siÍ oni skupiÊ g≥Ûwnie na logice aplikacji.


\section{Logika gry - skrypty}
\label{Teoria:Skrypty}
\subsection{WstÍp}
\label{Teoria:Skrypty:Wstep}
Ma≥e gry ze zdefiniowanym celem i fabu≥π wykorzystujπ niewielkπ iloúÊ modeli i grafik. W takich produkcjach programiúci programujπ poziomy bezpoúrednio w kodzie aplikacji. W wiÍkszych przedsiÍwziÍciach zachodzi koniecznoúÊ oddzielenia czÍúci logicznej od kodu aplikacji z dwÛch powodÛw:
\begin{itemize}
    \item Tworzeniem poziomÛw zajmuje siÍ oddzielny zespÛ≥, z≥oøony z cz≥onkÛw, ktÛrzy najczÍúciej nie zajmujπ siÍ programowaniem
    \item Kaøda, nawet najmniejsza zmiana fragmentu logiki, wiπøe siÍ z ponownπ kompilacjπ ca≥ej aplikacji
\end{itemize}

Wykorzystanie jÍzyka skryptowego rozwiπzuje ten problem. TwÛrcy gry nie tylko mogπ umieúciÊ w nich budowanie poziomÛw, ale takøe implementowaÊ nowe algorytmy AI, oprogramowywaÊ GUI~\footnote{ang: Graphical User Interface - Interfejs uøytkownika}, i wiele innych aspektÛw gry, ktÛre wymagajπ czÍstych zmian i szybkiego sprawdzenia w praktyce. \\

Skrypty sπ pisane w jÍzyku interpretowanym. Oznacza to, øe instrukcje sπ czytane po kolei i wykonywane, bez procesu kompilacji. W dawnych czasach jedynym wyjúciem by≥a w≥asna implementacja jÍzyka skryptowego i interpretera. Dzisiaj twÛrcy gier majπ do dyspozycji wiele gotowych. W projekcie praktycznym zosta≥ wykorzystany jÍzyk Lua, dlatego teø w≥aúnie on zostanie przedstawiony w niniejszym rozdziale.\\

\subsection{JÍzyk Lua}
\label{Teoria:Skrypty:Lua}

Lua to jÍzyk skryptowy przeznaczony g≥Ûwnie do rozszerzania funkcjonalnoúci aplikacji, jednak czÍsto jest stosowany jako samodzielny jÍzyk. Stworzony zosta≥ w 1993 roku przez trzech studentÛw katolickiego uniwersytetu w Rio de Janeiro.\\

JÍzyk ten zosta≥ zaimplementowany w ANSI C jako ma≥a, darmowa i przenoúna biblioteka. G≥Ûwnymi atutami sπ prostota i wydajnoúÊ. W≥aúnie te cechy sprawiajπ, øe jÍzyk Lua jest najczÍúciej wybieranym jÍzykiem dla potrzeb gier komputerowych.\\

\subsection{Sk≥adnia jÍzyka}
\label{Teoria:Skrypty:Skladnia}
Opis ca≥ej sk≥adni jÍzyka wykracza poza ramy tej pracy. Autor przedstawia jedynie podstawowe elementy jÍzyka.\\

Kod skryptÛw Lua przypomina jÍzyk Pascal. Zawiera jednak automatyczne mechanizmy zarzπdzania pamiÍciπ, dziÍki ktÛrym znikajπ problemy zwiπzane z wyciekami pamiÍci czy przepe≥nieniami buforÛw. Jest to jÍzyk dynamicznych typÛw, co oznacza, øe typ zmiennych oraz ich instancje sπ tworzone przy pierwszym przypisaniu do nich wartoúci:

\begin{lstlisting}[language=Pascal,caption={Dynamiczna zmiana typu zmiennej}]

--Prosty komentarz
--[[
    Wieloliniowy komentarz
]]--
zmienna = 5
zmienna = false
zmienna = "Hello!"
\end{lstlisting}

Podstawowe typy danych to: nil, boolean, number, string, funkcja, userdata i tablica. Nil jest typem z jednπ wartoúciπ \texttt{nil}, ktÛra reprezentuje brak wartoúci. Typ logiczny jaki reprezentuje Nil to \texttt{false}. Typ userdata jest przydatny podczas komunikacji Lua z innymi jÍzykami i moøe przechowywaÊ dowolnπ wartoúÊ. Tablice sπ dynamicznym asocjacyjnym zbiorem danych, ktÛry moøe przechowywaÊ dane dowolnego typu, z wyjπtkiem wartoúci \texttt{nil}. Tablice sπ podstawπ budowania bardziej z≥oøonych typÛw takich jak mapy, listy, grafy, drzewa itp. DostÍpne sπ podstawowe instrukcje warunkowe i sterujπce: if, while, repeat, repeat-until i for.\\

WyrÛøniamy dwa rodzaje zmiennych: globalne i lokalne. Zmienne globalne sπ domyúlne i dostÍpne w ca≥ym kodzie. Zmienne lokalne wymagajπ poprzedzenia deklaracji s≥owem \texttt{local} i ograniczajπ siÍ jedynie do zakresu bloku, w ktÛrym siÍ znajdujπ:
\begin{lstlisting}[language=Pascal,caption={ZasiÍg zmiennych}]
zmiennaGlobalna = 5
if zmiennaGlobalna == 5 then
    local zmiennaLokalna = 25
end
print zmiennaGlobalna -- Wyúwietli wartoúÊ 5
print zmiennaLokalna -- B≥πd, zmienna nie istnieje
\end{lstlisting}

Funkcje w jÍzyku Lua mogπ przyjmowaÊ i zwracaÊ wiele wartoúci rÛønego typu. Parametry funkcji, ktÛrym nie zostanie podana wartoúÊ, przyjmujπ wartoúÊ \texttt{nil}:
\begin{lstlisting}[language=Pascal,caption={Parametry funkcji}]
function s(a, b)
   if a > 2 then
      return a+b, a*b
   else
      return a-b, a/b
   end
end
e,f, g = s(3, 1)
-- e = 4, f = 3, g = nil
h = s(1, 3)
-- h = -2
\end{lstlisting}

JÍzyk Lua nie ma wbudowanej obs≥ugi obiektÛw i klas. Jedynπ strukturπ danych jest Tabela, jednak uøywa siÍ jej do implementowania innych typÛw za pomocπ \mbox{meta-tablic}~\footnote{ang: metatable}. Umoøliwiajπ one zmianÍ zachowania tablic. Prostym przyk≥adem moøe byÊ tablica przechowujπca wektor 3d, majπcy trzy pola reprezentujπce wspÛ≥rzÍdne. Podczas operacji dodawania dwÛch takich obiektÛw Lua sprawdza, czy istnieje \mbox{meta-metoda} o nazwie \_\_add, ktÛrπ programista moøe zaimplementowaÊ w celu obs≥uøenia dodawania dwÛch wektorÛw.

\subsection{Integracja z jÍzykiem C++}
\label{Teoria:Skrypty:Integracja}

Biblioteka Lua umoøliwia wymianÍ informacji oraz wywo≥ywanie funkcji Lua w kodzie C++ i odwrotnie. Podczas wymiany informacji tworzony jest wirtualny stos, na ktÛrym umieszczane sπ parametry funkcji i wartoúci zwracane. Dla kaødego wywo≥ania tworzony jest oddzielny stos. DziÍki temu wywo≥ujπc z poziomu C++ funkcjÍ Lua, ktÛra w swoim ciele wywo≥uje innπ funkcjÍ C++, mamy za kaødym razem dostÍp do osobnego stosu kaødego z wywo≥aÒ i moøemy je obs≥uøyÊ bez øadnych kolizji. Do wartoúci przechowywanych na stosie moøemy odwo≥aÊ siÍ uøywajπc dwÛch sposobÛw: indeksy dodatnie pobierajπ wartoúci od do≥u (od najstarszego elementu), indeksy ujemne pobierajπ wartoúci od gÛry. Proces wywo≥ania funkcji ze skryptu sk≥ada siÍ z:
\begin{enumerate}
    \item Umieszczenia parametrÛw funkcji na stosie
    \item Wywo≥ania funkcji ze skryptu
    \item Pobrania zwracanych przez funkcjÍ wartoúci ze stosu
\end{enumerate}
Z poziomu C++ moøemy rÛwnieø uzyskaÊ dostÍp do wszystkich zmiennych globalnych w skrypcie. \\

Wywo≥ywanie funkcji jÍzyka C++ w skrypcie jest moøliwe poprzez rejestracjÍ statycznej metody poúredniczπcej. Jej parametrem jest wskaünik do obiektu, za pomocπ ktÛrego mamy dostÍp do metod umieszczajπcych i pobierajπcych informacje ze stosu.\\

£πczenie skryptÛw Lua z jÍzykiem C++ jest niekiedy trudnym zadaniem, dlatego stworzone zosta≥y zewnÍtrzne biblioteki wspomagajπce wymianÍ informacji, a takøe wprowadzajπce ulepszenia takie jak obs≥uga programowania obiektowego oraz dostÍpu do klas i obiektÛw kodu C++ z poziomu skryptu.

\subsubsection{ToLua++}
\label{Teoria:Skrypty:ToLua}
ToLua++ jest bibliotekπ, ktÛra umoøliwia eksportowanie klas z C++ za pomocπ definicji klasy umieszczonej w osobnym pliku. W skrypcie moøna korzystaÊ z tych klas tak jakby by≥y fizycznie klasami Lua. Obs≥ugiwany jest polimorfizm obiektÛw i klas, a takøe dziedziczenie jednokrotne i wielodziedziczenie. Moøliwe jest takøe przeciπøanie funkcji i operatorÛw.

\subsubsection{LuaBind}
\label{Teoria:Skrypty:LuaBind}
O ile ToLua++ jest jedynie narzÍdziem wspomagajπcym integracjÍ Lua z C++, \mbox{LuaBind} jest oddzielnπ wersjπ jÍzyka, ktÛra rozszerza jego moøliwoúci, jednoczeúnie zapewniajπc wygodnπ formÍ rejestrowania klas i metod. G≥Ûwnπ zaletπ \mbox{LuaBind} jest uniezaleønienie od stosu jÍzyka Lua, dziÍki czemu moøliwe jest wywo≥ywanie bezpoúrednich metod jÍzyka C++ bez potrzeby implementowania funkcji poúredniczπcych.

% ********** Koniec rozdzia≥u **********

% ********** Rozdzia≥ 3 - PRAKTYKA **********
\chapter{Praktyka}
\label{Praktyka}
CzÍúÊ praktyczna pracy opisuje proces tworzenia projektu. Zosta≥a podzielona na dwie czÍúci:
\begin{enumerate}
    \item \textbf{Architektura silnika} -- Opis architektury i dzia≥ania silnika graficznego, na podstawie ktÛrego tworzona bÍdzie gra, oraz zewnÍtrznych narzÍdzi wykorzystanych przy procesie tworzenia.
    \item \textbf{Tworzenie gry AtBall} -- Proces tworzenia w≥aúciwej gry.
\end{enumerate}

\section{Architektura silnika}
\label{Praktyka:Architektura}

\subsection{WstÍp}
\label{Praktyka:Architektura:Wstep}
Pierwszym krokiem podczas tworzenia projektu by≥o stworzenie silnika graficznego, ktÛry umoøliwia≥by przygotowywanie prostych gier platformowych. Autor zdecydowa≥ siÍ na jak najdok≥adniejsze oddzielenie procesu kreowania gry od kodu ürÛd≥owego aplikacji. W tym celu zosta≥ wykorzystany zewnÍtrzny edytor úwiata, w ktÛrym twÛrca gry przygotowuje scenÍ ustawiajπc pozycjÍ, orientacjÍ i skalÍ obiektÛw, a takøe ustawia tekstury. Majπc gotowy uk≥ad modeli nastÍpuje przygotowanie odpowiednich skryptÛw, ktÛre okreúlajπ zachowanie obiektÛw podczas gry. G≥Ûwnπ funkcjπ jest moøliwoúÊ obs≥ugi kolizji obiektÛw, dziÍki czemu budowanie fabu≥y gry staje siÍ ≥atwe i przyjemne.

\subsubsection{NarzÍdzia}
\label{Praktyka:Architektura:Wstep:Narzedzia}
Proces tworzenia projektu wymaga≥ wykorzystania nastÍpujπcych narzÍdzi oraz bibliotek:

\begin{itemize}
    \item \textbf{Microsoft Visual Studio} -- Zintegrowane úrodowisko programistyczne umoøliwiajπce tworzenie, testowanie i debugowanie zaawansowanych aplikacji (takøe aplikacji sieciowych oraz serwisÛw internetowych).
    \item \textbf{Visual Assist X} -- Dodatek do Visual Studio poprawiajπcy i rozszerzajπcy wybrane funkcje úrodowiska. G≥Ûwnπ cechπ jest lepsza obs≥uga IntelliSense~\footnote{Podpowiadanie sk≥adni} i kolorowania sk≥adni. Dodatkowo u≥atwia utrzymywanie porzπdku w kodzie ürÛd≥owym za pomocπ refractoringu~\footnote{Dynamiczna zmiana wybranych nazw zmiennych, klas, metod itd.}.
    \item \textbf{Microsoft DirectX} -- Biblioteka wspomagajπca wyúwietlanie grafiki na ekranie.
    \item \textbf{NVIDIA PhysX} -- Silnik fizyczny firmy NVIDIA umoøliwiajπcy stworzenie wirtualnej sceny, zapewniajπcej obiektom fizyczne oddzia≥ywanie miÍdzy sobπ.
    \item \textbf{IrrEdit} -- Darmowy edytor úwiata, umoøliwiajπcy tworzenie scen zawierajπcych nie tylko modele 3D, ale rÛwnieø kamery, úwiat≥a i dynamicznie generowane tereny. Wygenerowanπ scenÍ moøna zapisaÊ w wygodnym formacie XML.
    \item \textbf{IrrXML} -- Darmowa biblioteka umoøliwiajπca parsowanie plikÛw XML.
    \item \textbf{Lua} -- Biblioteka zapewniajπca obs≥ugÍ skryptÛw napisanych w jÍzyku Lua.
\end{itemize}

\subsection{Inicjalizacja}
\label{Praktyka:Architektura:Inicjalizacja}
Niniejszy rozdzia≥ zawiera ogÛlnikowπ prezentacjÍ procesu inicjalizacji oraz dzia≥ania silnika. Wybrane klasy i mechanizmy zostanπ omÛwione dok≥adniej w dalszej czÍúci pracy.

\subsubsection{Game - g≥Ûwny obiekt gry}
\label{Praktyka:Architektura:Inicjalizacja:CGame}
Klasa \code{CGame} jest jπdrem ca≥ego silnika. Odpowiada za inicjalizacjÍ poszczegÛlnych modu≥Ûw, obs≥ugÍ g≥Ûwnej pÍtli oraz zarzπdzanie stanami gry. Wykorzystuje ona wzorzec projektowy \textbf{Singleton} (wydruk \ref{code:singleton}):

\begin{lstlisting}[caption={Singleton},label={code:singleton}]
class CGame{
private:
	CGame();
public:
	~CGame();
	static CGame& GetInstance(){
		static CGame inst;
		return inst;
	}
(...) //pozosta≥e metody
}
#define Game CGame::GetInstance()
\end{lstlisting}

Zapewnia on dostÍp tylko do jednej instancji obiektu za pomocπ metody \code{GetInstance()}, ktÛra zwraca referencjÍ na obiekt. Konstruktor jest prywatny, tak wiÍc rÍczne stworzenie obiektu klasy \code{CGame} jest niemoøliwe. Instrukcja preprocesora \code{\#define} tworzy alias, dziÍki ktÛremu za pomocπ nazwy \code{Game} moøemy wywo≥ywaÊ poszczegÛlne metody klasy \code{CGame}.\\

Uruchomienie aplikacji polega na wywo≥aniu metody \code{CGame::Run()} (wydruk \ref{code:cgame}). 

\begin{lstlisting}[caption={Uruchomienie gry},label={code:cgame}]
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd){
	int result = Game.Run(hInstance,nShowCmd);
	return result;
}
\end{lstlisting}

Metoda ta wykonuje dwie operacje. Pierwszπ z nich jest zainicjowanie poszczegÛlnych komponentÛw wymaganych do dalszego funkcjonowania silnika. W praktyce sprowadza siÍ to do wykonania metody \code{X::Init()}, gdzie \code{X} jest aliasem do klasy, ktÛra jest singletonem, zbudowanym na wzÛr klasy \code{CGame}.\\

Proces inicjalizacji przebiega nastÍpujπco:
\begin{enumerate}
    \item Za≥adowanie skryptu konfiguracyjnego, ktÛry zawiera wybranπ rozdzielczoúÊ oraz nazwÍ pierwszego poziomu gry.
    \item Inicjalizacja obiektu \code{Window}, ktÛry tworzy okno programu.
    \item Inicjalizacja obiektu \code{DirectX} tworzπcego obiekty urzπdzeÒ wykorzystywanych w procesie renderingu. £adowane sπ rÛwnieø trzy pliki efektÛw (shadery): normalny, z efektem mapowania wypuk≥oúci (normal mapping) i dla SkyBox'a.
    \item Inicjalizacja systemu wejúcia \code{Input} odpowiedzialnego za wykrywanie operacji wejúciowych z klawiatury i myszy.
    \item Inicjalizacja obiektÛw \code{PhysX} oraz \code{Scene} odpowiedzialnych za obs≥ugÍ silnika NVIDIA PhysX, oraz zarzπdzanie obiektami w scenie.
    \item Inicjalizacja pozosta≥ych sk≥adnikÛw: \code{SoundMgr} odpowiedzialny za obs≥ugÍ düwiÍku, \code{Gui} zajmujπcy siÍ wyúwietlaniem grafiki 2D (interfejs uøytkownika, komunikaty itp.) oraz \code{SkyBox} ≥adujπcy teksturÍ szeúciennπ i wyúwietlajπcy jπ imitujπc sztuczne t≥o úwiata.
\end{enumerate}

\subsubsection{Stany}
\label{Praktyka:Architektura:Inicjalizacja:Stany}
Stan okreúla sposÛb dzia≥ania aplikacji, reakcji na operacje wejúciowe uøytkownika, oraz wyúwietlanie obrazu na ekranie.

\begin{itemize}
    \item \textbf{start1, start2} -- Odpowiedzialne za wyúwietlenie dwÛch poczπtkowych obrazÛw bezpoúrednio po uruchomieniu aplikacji.
    \item \textbf{mainMenu} -- Wyúwietlenie menu gry oraz reakcja na zmianÍ i wybÛr konkretnej pozycji.
    \item \textbf{instructions} -- Wyúwietlenie obrazu zawierajπcego informacje na temat gry oraz sterowania.
    \item \textbf{loading, loading2} -- Stan \textbf{loading} powoduje wyúwietlenie ekranu informujπcego o procesie ≥adowania poziomu oraz zmianÍ na stan \textbf{loading2}, ktÛry wywo≥uje metodÍ \code{CGame::NextLevel()} ≥adujπcπ nowy poziom.
    \item \textbf{game} -- Symulacja obiektÛw na scenie oraz wyúwietlenie ich na ekranie.
    \item \textbf{pause, softPause} -- Pauza gry, w ktÛrej nastÍpuje zatrzymanie symulacji i sterowania obiektami. W stanie \textbf{pause} dodatkowo obraz sceny zastÍpowany jest przez obraz informujπcy o zatrzymaniu gry.
    \item \textbf{endGame, closing} -- Stany odpowiedzialne za wyúwietlenie informacji o zamykaniu aplikacji oraz usuwanie obiektÛw i koÒczenie dzia≥ania programu. 
    \item \textbf{error} -- Wyúwietlenie komunikatu o b≥Ídzie oraz zamykanie programu.
\end{itemize}

Przejúcia miÍdzy stanami zachodzπ w trzech przypadkach:
\begin{enumerate}
    \item Po up≥ywie okreúlonego czasu. Przyk≥adem jest droga: start1 $\shortrightarrow$ start2 $\shortrightarrow$ mainMenu, w ktÛrej stan zmieniany jest na kolejny po up≥ywie okreúlonej liczby sekund.
    \item Po akcji uøytkownika np. wciúniÍcie przycisku ENTER przy wybranej opcji menu.
    \item RÍczna zmiana stanu poprzez wywo≥anie metody \code{CGame::ChangeStatus(nowyStan)}.
\end{enumerate}

\subsubsection{PÍtla gry}
\label{Praktyka:Architektura:Inicjalizacja:Petla}
Po utworzeniu wymaganych urzπdzeÒ i przygotowaniu obiektÛw nastÍpuje uruchomienie pÍtli czasu rzeczywistego. Wykonuje siÍ ona przez ca≥y okres dzia≥ania aplikacji. Przerwanie jej powoduje wywo≥anie metody \code{CGame::Clear()}, ktÛra jest odpowiedzialna za bezpieczne usuwanie urzπdzeÒ i obiektÛw.\\

PÍtlÍ moøna podzieliÊ jπ na cztery czÍúci:
\begin{enumerate}
    \item Sprawdzenie, czy nie zosta≥ ustawiony stan \textbf{closing}. Jeúli tak -- pÍtla jest przerywana.
    \item Domyúle obs≥uøenie zdarzeÒ przez system operacyjny (np. maksymalizacja lub zmiana rozmiaru okna).
    \item Uaktualnienie logiki aplikacji.
    \item Wyúwietlenie grafiki.
\end{enumerate}

Dwie ostatnie operacje mogπ spowodowaÊ b≥πd, z powodu ktÛrego dalsze poprawne dzia≥anie aplikacji moøe staÊ siÍ niemoøliwe. W takim przypadku rÛwnieø pÍtla jest przerywana (wydruk \ref{code:petla}):

\begin{lstlisting}[caption={PÍtla gry},label={code:petla}]
int CGame::Run(...){
	(..) //inicjalizacja silnika
	MSG msg;
	while (true){
		if(status == closing) break; //zamykanie aplikacji
		if (PeekMessage( &msg, NULL, 0, 0, PM_REMOVE)){
			if(msg.message == WM_QUIT) break;
			TranslateMessage(&msg);	DispatchMessage(&msg);
		}
		if(Update() == false) break; //b≥πd logiki - przerywanie
		if(Render() == false) break; //b≥πd wyúwietlania - przerywanie
	}
	Clear(); return 0;
}
\end{lstlisting}

\subsubsection{Uaktualnianie logiki}
\label{Praktyka:Architektura:Inicjalizacja:Logika}
Proces uaktualniania logiki sk≥ada siÍ z dwÛch g≥Ûwnych operacji:
\begin{enumerate}
    \item Wywo≥anie metody \code{Update()} dla poszczegÛlnych obiektÛw g≥Ûwnych.
    \item Reakcja na zdarzenia wygenerowane przez uøytkownika.
\end{enumerate}

Pierwszπ czynnoúciπ jest uaktualnienie obiektÛw niezaleønych od aktualnego stanu gry:
\begin{itemize}
    \item \textbf{FPSCounter} odpowiada za obliczanie rÛønicy czasu miÍdzy dwiema iteracjami pÍtli gry oraz wyliczanie wartoúci FPS.
    \item \textbf{SoundMgr} uaktualnia system düwiÍku (wiÍcej o obs≥udze düwiÍku w rozdziale \ref{Praktyka:Architektura:Dzwiek}).
    \item \textbf{TimerMgr} zajmuje siÍ uaktualnianiem czasu zegarÛw, oraz wykonywanie okreúlonych akcji (wiÍcej o zarzπdzaniu czasem w rozdziale \ref{Praktyka:Architektura:Timery}).
    \item \textbf{Input} pobiera aktualny stan urzπdzeÒ wejúciowych.
\end{itemize}

NastÍpnie w zaleønoúci od ustawionego stanu gry nastÍpuje sprawdzenie wciúniÍtych klawiszy. \\

Dla stanu \textbf{game} sprawdzane jest wybranie pauzy gry oraz restartu poziomu. W zaleønoúci od tego czy uøytkownik wybra≥ øπdane dzia≥anie, stan gry jest zmieniany na \textbf{pause} lub \textbf{loading}. Dodatkowo sprawdzana jest reakcja na przycisk ESC, ktÛry powoduje przejúcie do stanu \textbf{mainMenu} oraz spacji, ktÛrej wciúniÍcie jest sygnalizowane poprzez wywo≥anie metody w skrypcie danego poziomu.\\

W przypadku stanu \textbf{instructions} po wciúniÍciu klawisza ESC nastÍpuje powrÛt do stanu \textbf{mainMenu}.\\

Kolejnym krokiem jest uaktualnienie graficznego interfejsu uøytkownika (ktÛry zostanie opisany w rozdziale \ref{Praktyka:Architektura:Gui}) uwzglÍdniajπc ustawiony stan gry.\\

Jeúli aktualnym stanem gry jest \textbf{loading}, nastÍpuje przejúcie do stanu \textbf{loading2}, ktÛry przy kolejnej iteracji pÍtli gry za≥aduje nowy poziom.\\

Po wykonaniu powyøszych operacji, jeúli stan gry dalej jest ustawiony na \textbf{game}, nastÍpuje symulacja obiektÛw na scenie oraz uaktualnienie pozycji kamery.

\subsubsection{Wyúwietlanie obrazu}
\label{Praktyka:Architektura:Inicjalizacja:Grafika}
Wyúwietlenie obrazu sprowadza siÍ do wywo≥ania metody \code{CDirectx::Render()}. Na poczπtku nastÍpuje sprawdzenie czy urzπdzenie s≥uøπce do wyúwietlania obrazu nie zosta≥o stracone. Taka sytuacja moøe wystπpiÊ np. przy minimalizacji pe≥noekranowej aplikacji. Jeúli tak, dokonywana jest prÛba odzyskania urzπdzenia. W przypadku powodzenia proces renderingu jest kontynuowany. Jeúli urzπdzenie dalej jest stracone, dalsze wykonywanie metody zostaje wstrzymane. Moøe zaistnieÊ rÛwnieø sytuacja, w ktÛrej urzπdzenia nie da siÍ odzyskaÊ, wtedy dzia≥anie aplikacji zostaje zakoÒczone.\\

Status \textbf{game} oznacza renderowanie ekranu gry. Pierwszym krokiem jest wyúwietlenie skybox'a otaczajπcego ca≥π scenÍ. Tym zadaniem zajmuje siÍ klasa \code{CSkyBox}, ktÛra przy inicjalizacji silnika ≥aduje teksturÍ z pliku DDS (rysunek \ref{img:skybox}) oraz tworzy model szeúcianu. NastÍpnie podczas renderowania nak≥adana jest na niego za≥adowana tekstura tworzπc szeúcian otaczajπcy ca≥π scenÍ. \\

\begin{figure}[h]
\centering
\includegraphics[width=80mm]{img/skybox.jpg}
\caption{Tekstura mapujπca sztuczne t≥o úwiata}
\label{img:skybox}
\end{figure}

NastÍpnie wyúwietlane sπ obiekty ze sceny. Dla kaødego typu shadera (normalny i mapowanie wypuk≥oúci) wywo≥ywana jest metoda \code{CScene::Render(typ)} podajπc jako parametr typ shadera. SzczegÛ≥owy proces renderowania sceny oraz poszczegÛlnych obiektÛw zostanie opisany w kolejnych rozdzia≥ach.\\

Ca≥a scena renderowana jest do tekstury w celu na≥oøenia efektÛw takich jak sepia, rozmycie lub zamiana kolorÛw na czarno-bia≥e. Zostaje ona na≥oøona na kwadratowy model, ktÛry jest wyúwietlany na powierzchni ca≥ego ekranu. Nazwa efektu, ktÛrπ moøna ustawiÊ za pomocπ metody \code{CDirectx::SetPostProcessingEffect()}, jest nazwπ techniki zaimplementowanej w pliku \textbf{post.fx}.\\

Ostatnim etapem jest wywo≥anie metody \code{CGui::Render()}, ktÛra w zaleønoúci od aktualnego stanu gry wyúwietla odpowiednie elementy interfejsu uøytkownika.\\



\subsection{Grafika 2D - Interfejs uøytkownika}
\label{Praktyka:Architektura:Gui}
Waønym aspektem kaødej gry, oprÛcz wyúwietlanej grafiki 3D, sπ elementy dwuwymiarowe. NajczÍúciej sπ to okna (np. z wiadomoúciπ), przyciski (np. menu g≥Ûwne gry) i grafiki pe≥noekranowe (zawierajπce informacje o ≥adowaniu poziomu lub pauzie gry). Za wyúwietlanie obrazÛw odpowiada klasa \code{CGame}. Wykorzystuje do tego obiekt typu \code{ID3DXSprite}, ktÛry dodatkowo umoøliwia rysowanie z uwzglÍdnieniem g≥Íbi oraz przezroczystoúci.\\

Podczas inicjalizacji silnika ≥adowane sπ wszystkie wymagane tekstury. Rozmiar obrazÛw pe≥noekranowych jest ustawiany na wysokoúÊ i szerokoúÊ okna (aktualna rozdzielczoúÊ). NastÍpnie wybrane z nich sπ wyúwietlane w zaleønoúci od ustawionego stanu gry.

\subsubsection{G≥Ûwne menu}
\label{Praktyka:Architektura:Gui:PelenWymiar}

Menu g≥Ûwne gry (rysunek \ref{img:gui}) sprowadza siÍ do narysowania nastÍpujπcych elementÛw:
\begin{enumerate}
    \item Obraz pe≥noekranowy stanowiπcy t≥o.
    \item Ramka menu.
    \item Przyciski.
\end{enumerate}

Wymiary ramki sπ skalowane wed≥ug proporcji, uwzglÍdniajπc rzeczywisty wymiar tekstury, aktualnπ i maksymalnπ rozdzielczoúÊ ekranu aplikacji. Pozycja oraz úrodek obiektu (wymagane przy pozycjonowaniu obrazka na ekranie) sπ wyliczane uwzglÍdniajπc obliczone wczeúniej nowe wymiary obrazka (wydruk \ref{code:gui}).

\begin{lstlisting}[caption={Proporcjonalne skalowanie obrazkÛw},label={code:gui}]
menuBackgroundX = (900 * Window.GetWidth()) / 1920;
menuBackgroundY = (774 * Window.GetHeight()) / 1200;
menuBackgroundPos = D3DXVECTOR3(Window.GetWidth()/2,Window.GetHeight()/2,0.0f);
menuBackgroundCen = D3DXVECTOR3(menuBackgroundX/2,menuBackgroundY/2,0.0f);
\end{lstlisting}

Pozycja i wymiar przyciskÛw jest wyliczany analogicznie, jednak brana jest pod uwagÍ rÛwnieø wartoúÊ przesuniÍcia obiektÛw w gÛrÍ i w dÛ≥.\\

Dzia≥anie kaødego przycisku okreúla klasa \code{CGuiButton}. Zawiera informacje takie jak:
\begin{enumerate}
    \item Wyúwietlany tekst na przycisku.
    \item Informacja o zaznaczeniu. WyrÛøniamy dwa stany:
\begin{itemize}
    \item WciúniÍty - przycisk jest rysowany nieprzezroczysty.
    \item Zwolniony - dodawana jest przezroczystoúÊ.
\end{itemize}
    \item Akcja, ktÛra zostanie wykonana w przypadku wciúniÍcia ENTER na wybranym przycisku. W praktyce jest to po prostu zmiana stanu gry. DostÍpne sπ cztery moøliwoúci:
\begin{itemize}
    \item \textbf{START} -- Stan \textbf{loading}.
    \item \textbf{RESUME} -- Stan \textbf{game}.
    \item \textbf{INSTRUCTIONS} -- Stan \textbf{instructions}.
    \item \textbf{EXIT} -- Stan \textbf{endGame}.
\end{itemize}
\end{enumerate}

\begin{figure}[h]
\centering
\includegraphics[width=90mm]{img/gui.jpg}
\caption{Menu g≥Ûwne gry}
\label{img:gui}
\end{figure}

Metoda \code{CGame::Update()} sprawdza czy aktualnym stanem gry jest \textbf{mainMenu}. Jeúli tak, nastÍpuje sprawdzenie wciúniÍcia klawiszy "strza≥ka w gÛrÍ" i "strza≥ka w dÛ≥", ktÛre umoøliwiajπ wybÛr opcji w menu. Po wykryciu wciúniÍtego klawisza ENTER nastÍpuje wykonanie akcji przypisanej do wybranego przycisku.

\subsubsection{Okno wiadomoúci}
\label{Praktyka:Architektura:Gui:Okno}
Okno wiadomoúci jest wyúwietlane w stanie \atbold{game} i \atbold{softPause}. Jego treúÊ jest ustawiana za pomocπ metody \code{CGui::SetMessage()}. Proces rysowania polega na wyúwietleniu przezroczystego ekranu okienka, oraz na≥oøenia tekstu wiadomoúci (rysunek \ref{img:gui2}). W przypadku ustawienia pustej wiadomoúci rysowanie okna zostaje pominiÍte.

\begin{figure}[h]
\centering
\includegraphics[width=90mm]{img/message.jpg}
\caption{Okno wiadomoúci w trakcie gry}
\label{img:gui2}
\end{figure}

\subsection{Zasoby}
\label{Praktyka:Architektura:Zasoby}
Model siatki wierzcho≥kÛw (mesh) jest przechowywany w klasie \code{CMesh}. Zawiera ona wskaünik na w≥aúciwy model \code{ID3DXMesh}. OprÛcz ≥adowania modelu z pliku wykonuje takøe dodatkowe operacje, takie jak wyliczanie wektorÛw normalnych dla modelu i optymalizacja wierzcho≥kÛw. DostÍpne sπ rÛwnieø metody przygotowujπce kszta≥t aktora triangle mesh i convex mesh, oraz funkcja skalujπca model.\\

Klasa \code{CTexture} odpowiada za przechowywanie obiektu \code{IDirect3DTexture9} zawierajπcego za≥adowanπ teksturÍ.

\subsubsection{Menedøer zasobÛw}
\label{Praktyka:Architektura:Zasoby:Menedzer}
Tworzeniem oraz zarzπdzaniem modelami i teksturami zajmuje siÍ klasa \code{CMedia}. Wykorzystuje ona wzorzec singleton, dziÍki czemu jej instancja jest dostÍpna w dowolnym miejscu programu. Zwiera dwie mapy przechowujπce wskaüniki do obiektÛw \code{CMesh} i \code{CTexture}. Indeksowane sπ za pomocπ ciπgu znakÛw, dziÍki czemu istnieje moøliwoúÊ nadawania unikalnych nazw dla poszczegÛlnych elementÛw.\\

G≥Ûwnymi zadaniami menedøera zasobÛw sπ:
\begin{itemize}
    \item Dodawanie obiektÛw (lub ich automatyczne tworzenie po podaniu nazwy pliku).
    \item Usuwanie obiektÛw.
    \item Pobieranie obiektÛw (np. w celu wyúwietlenia ich na ekranie).
    \item Czyszczenie pamiÍci zajmowanej przez obiekty (wykonywane przy koÒczeniu dzia≥ania aplikacji).
\end{itemize}

\subsection{Obiekty w grze}
\label{Praktyka:Architektura:Obiekty}
Kaødy widzialny obiekt wystÍpujπcy na scenie musi implementowaÊ interfejs \code{IRenderable}, ktÛry wymusza przedefiniowanie metod \code{Render()}, \code{Update()} oraz \code{GetPosition()}. Zawiera rÛwnieø podstawowe dane dotyczπce obiektu: nazwÍ, widocznoúÊ (ktÛra okreúla czy dany obiekt ma byÊ wyúwietlany) oraz typ (zwyk≥y lub wykorzystujπcy efekt mapowania wypuk≥oúci).

\subsubsection{Podstawowy obiekt - CEntity}
\label{Praktyka:Architektura:Obiekty:Podstawowy}
Podstawowπ klasπ reprezentujπcπ obiekt w przestrzeni 3D jest \code{CEntity}. Przechowuje ona niezbÍdne wartoúci wymagane do uaktualniania stanu oraz wyúwietlania modelu takie jak:
\begin{itemize}
    \item Wskaünik do obiektu \code{CMesh}.
    \item Wskaünik do tekstury obiektu (klasa \code{CTexture}).
    \item Macierze pozycji, rotacji i skalowania.
    \item Wektor rotacji (animacji obiektu) dziÍki ktÛremu moøemy obiekt wprawiÊ w rotacjÍ.
    \item Tekstura zawierajπca wektory normalne (normal mapa) w przypadku obiektÛw wykorzystujπcych efekt mapowania normalnych.
    \item Bry≥a otaczajπca wykorzystywana w metodzie optymalizacyjnej Frustrum Culling. Jest ona reprezentowana przez obiekt klasy \code{CFrustrumShape} ktÛra na podstawie ustawionego mesha generuje otaczajπcy jπ boks lub kulÍ.
\end{itemize}

Uaktualnianie stanu obiektu za pomocπ metody \code{Update()} polega na wyliczeniu nowych wartoúci rotacji obiektu na podstawie ustawionych wczeúniej wartoúci animacji. Jeúli sπ one ustawione na 0 obiekt nie zmienia orientacji.\\

Proces wyúwietlania obiektu zosta≥ rozdzielony na dwie metody:
\begin{enumerate}
    \item \code{Render()} -- Sprawdza, czy obiekt znajduje siÍ w bryle widzenia obserwatora (wykorzystujπc bry≥Í otaczajπcπ).
    \item \code{RenderEx()} -- Ustawia odpowiednie parametry pliku efektu i rysuje model. Ta metoda wywo≥ywana jest wewnπtrz metody \code{Render()}.
\end{enumerate}


\subsubsection{Aktor w symulacji sceny PhysX - CEntityEx}
\label{Praktyka:Architektura:Obiekty:Aktor}
W celu dodania obiektu do symulacji fizycznej naleøy stworzyÊ aktora oraz ustawiÊ jego fizyczne w≥aúciwoúci. Wykorzystywana jest do tego rozszerzona klasa \code{CEntityEx} odpowiedzialna za przygotowanie kszta≥tu aktora i dodania go do symulacji. Zawiera (oprÛcz podstawowych z klasy bazowej \code{CEntity}) nastÍpujπce dodatkowe wartoúci:
\begin{itemize}
    \item Obiekt typu \code{NxActor} przechowujπcy wskaünik do aktora na scenie.
    \item Kszta≥t obiektu w symulacji.
\end{itemize}

Opcjonalne wartoúci:
\begin{itemize}
    \item Obiekt klasy \code{CForceField} przypisujπcy pole si≥owe do danego aktora o okreúlonej sile i rozmiarze.
    \item Obiekt sterowania aktorem. 
    \item Obiekt klasy \code{CTrigger} (wiÍcej w rozdziale \ref{Praktyka:Architektura:Obiekty:Kolizje}).
\end{itemize}

\subsubsection{Sterowanie}
\label{Praktyka:Architektura:Obiekty:Sterowanie}
Sterowanie obiektem jest moøliwe po utworzeniu obiektu klasy implementujπcej interfejs \code{IUpdateable}, zawierajπcego metodÍ \code{Update()} wywo≥ywanπ przy kaødym uaktualnieniu obiektu, a nastÍpnie przypisaniu go do docelowego obiektu.\\

Przyk≥adowπ klasπ obs≥ugujπcπ sterowanie obiektem klasy \code{CEntityEx} jest \code{CStoneControl}. Proces uaktualniania pozycji jest nastÍpujπcy:
\begin{enumerate}
    \item Sprawdzenie stanu gry: tylko stan \atbold{game} umoøliwia sterowanie obiektem.
    \item Pobranie pozycji aktora i kamery.
    \item Wyliczenie kierunku obiektu:
$$\vec{Direction} = \vec{cameraPosition} - \vec{entityPosition}$$
OdwrÛcenie wektora:
$$\vec{Direction} = \vec{Direction} * (-1)$$
Wyzerowanie wartoúci Y (nadawanie si≥ odbywa siÍ jedynie w kierunku osi X i Z)
$$\vec{Direction.y} = 0$$
Normalizacja wynikowego wektora:
$$normalize(\vec{Direction})$$
	\item Ewentualne obs≥uøenie øπdania wyzerowania si≥. Odbywa siÍ to w dwÛch krokach:
\begin{itemize}
    \item Uúpienie aktora za pomocπ metody \code{NxActor::putToSleep()}.
    \item Obudzenie aktora za pomocπ jednorazowego nadania minimalnej wartoúci si≥y w dowolnym kierunku.
\end{itemize}
    \item Reakcja na wciúniÍte klawisze strza≥ek na klawiaturze i ewentualnie nadanie si≥ w okreúlonym kierunku:
\begin{itemize}
    \item GÛra: kierunek do przodu wyliczony z powyøszego wzoru
    \item DÛ≥: kierunek odwrÛcony
    \item Lewo, Prawo: wektor kierunkowy jest obracany o +/- $90^\circ$
\end{itemize}
\end{enumerate}

\subsubsection{Obs≥uga kolizji}
\label{Praktyka:Architektura:Obiekty:Kolizje}
Klasa \code{CEntityEx} zawiera mapy procedur skryptowych wykonywanych w wypadku wystπpienia kolizji sprawdzanego obiektu z innym.
\begin{lstlisting}[caption={Kontenery zawierajπce nazwy metod do obs≥ugi kolizji},label={code:mapyMetod}]
map<NxContactPairFlag, string> callbackProcedures;
map<NxShapeFlag, string> triggerProcedures;
\end{lstlisting}

WyrÛøniamy dwa typy kolizji:
\begin{enumerate}
    \item Proste kolizje zachodzπce miÍdzy obiektami. Za ich obs≥ugÍ odpowiada klasa \\ \code{CCollisionResponse}, ktÛra w przypadku wystπpienia kolizji sprawdza ustawienie procedury odpowiedzialnej za dany typ kolizji (np. \code{NX\_NOTIFY\_ON\_START\_TOUCH}). Jeúli taka jest ustawiona, nastÍpuje jej wywo≥anie.
    \item Wejúcie w okreúlony obszar (a takøe opuszczenie go lub pozostawanie w jego wnÍtrzu). Taki obszar moøe byÊ przypisany do konkretnego aktora za pomocπ obiektu klasy \code{CTrigger}, ktÛra generuje prostopad≥oúcian o okreúlonych wymiarach i ustawia go na pozycji obiektu. Obs≥ugπ zdarzeÒ generowanych poprzez kontakt obiektÛw z danym obszarem zajmuje siÍ klasa \code{CTriggerCallback}, ktÛra, podobnie jak w przypadku prostych kolizji, sprawdza istnienie przypisanej metody i wywo≥uje jπ.
\end{enumerate}

\subsubsection{£πczenie obiektÛw}
\label{Praktyka:Architektura:Obiekty:Laczenie}
CzÍsto wystÍpuje sytuacja, w ktÛrej istnieje potrzeba stworzenia obiektu dynamicznego ze skomplikowanego modelu. Poniewaø takie modele najczÍúciej zawierajπ wklÍs≥e fragmenty i sπ z≥oøone z wiÍkszej liczby trÛjkπtÛw - wygenerowanie convex mesha nie jest moøliwe. Problem ten zosta≥ rozwiπzany przy pomocy ≥πczenia obiektÛw.\\

Klasa \code{CEntityEx} zawiera opcjonalne pole zawierajπce wskaünik do obiektu typu prostego (\code{CEntity}). Proces ≥πczenia wyglπda nastÍpujπco (przyjmujπc, øe obiekt \atbold{A} jest typu \code{CEntity}, a obiekt \atbold{B} typu \code{CEntityEx}):
\begin{enumerate}
    \item Stworzenie obiektu widzialnego \atbold{A} (w≥aúciwy wyúwietlany model).
    \item Stworzenie obiektu \atbold{B}, w ktÛrym modelem jest przygotowany wczeúniej model reprezentujπcy wypuk≥y kszta≥t kolizyjny w symulacji (niewyúwietlany na ekranie).
    \item Przypisanie obiektowi \atbold{B} obiektu ≥πczπcego \atbold{A}. Po tej operacji obiekt \atbold{A} jest usuwany ze sceny.
\end{enumerate}

Wyúwietlanie modelu polega na pobraniu nowej pozycji i orientacji z obiektu \atbold{B}, ktÛry istnieje w scenie oraz podlega symulacji fizycznej, a nastÍpnie przekazaniu jej do metody \code{CEntity::RenderEx()} obiektu \atbold{A}, ktÛra rysuje widzialny obiekt na wskazanej pozycji i ze wskazanπ orientacjπ.

\subsubsection{Zarzπdzanie obiektami}
\label{Praktyka:Architektura:Obiekty:Zarzadzanie}
Przechowywaniem obiektÛw zajmuje siÍ menedøer obiektÛw. Podobnie jak menedøer zasobÛw zawiera on mapÍ obiektÛw typu \code{CEntity} (oraz klas pochodnych), umoøliwiajπc dodawanie, usuwanie i pobieranie jednostek. Umoøliwia rÛwnieø wyczyszczenie mapy jednoczeúnie usuwajπc wszystkie obiekty.

\subsection{Scena}
\label{Praktyka:Architektura:Scena}
Przechowywaniem widocznych na scenie obiektÛw oraz wykonywaniem symulacji fizycznej zajmuje siÍ klasa \code{CScene}. Umoøliwia ona dodawanie oraz usuwanie obiektÛw. Czyszczenie sceny usuwa jedynie informacje o przechowywanych obiektach. W≥aúciwym usuwaniem obiektÛw zajmujπ siÍ opisane w poprzednich rozdzia≥ach menedøery obiektÛw i zasobÛw. WyrÛøniamy dwa rodzaje scen:
\begin{itemize}
    \item Symulacja fizyczna
    \item Wyúwietlanie obiektÛw
\end{itemize}

\subsubsection{Symulacja fizyczna}
\label{Praktyka:Architektura:Scena:Symulacja}
Podczas inicjalizacji silnika tworzona jest wirtualna scena. Ustawiana jest grawitacja, rejestrowane sπ klasy reakcji na zdarzenia kolizji oraz tworzona jest dolna p≥aszczyzna, ktÛra odgranicza przestrzeÒ pustπ od zawierajπcej obiekty.\\

Wydruk \ref{code:symulacja} przedstawia instrukcje, ktÛre sπ wykonywane w celu dokonania pojedynczej symulacji. Pierwszym krokiem jest wywo≥anie metody \code{NxScene::simulate()}, ktÛra dokonuje symulacji kaødego obiektu, sumujπc wszystkie si≥y dzia≥ajπce na obiekty dynamiczne i odpowiednio je przemieszczajπc, a takøe wykrywa kolizje miÍdzy obiektami. NastÍpnπ operacjπ jest pobranie wynikÛw symulacji. Uaktualnia ona wszystkich aktorÛw na scenie, dziÍki czemu posiadajπ zaktualizowanπ pozycjÍ oraz orientacjÍ.

\begin{lstlisting}[caption={Wykonanie symulacji fizycznej},label={code:symulacja}]
scene->simulate(1.0f/60.0f);
scene->flushStream();
scene->fetchResults(NX_RIGID_BODY_FINISHED, true);
\end{lstlisting}

\subsubsection{Wyúwietlanie obiektÛw}
\label{Praktyka:Architektura:Scena:Wyswietlanie}
Klasa \code{CScene} zawiera dwie mapy obiektÛw typu \code{IRenderable} dla kaødego typu obiektu (zwyk≥y i normal mapping). Zmiana pliku efektu podczas renderowania jest kosztowna obliczeniowo. Wprowadzony podzia≥ zapewnia tylko jednπ zmianÍ w czasie przygotowywania klatki obrazu.\\

Metoda \code{CScene::Update()}, poza symulacjπ sceny fizycznej, wywo≥uje dla kaødego obiektu metodÍ \code{IRenderable::Update()}, ktÛra w przypadku obiektÛw typu \code{CEntityEx} uaktualnia nowπ pozycjÍ oraz orientacjÍ. Wyúwietlanie obiektÛw dokonuje siÍ poprzez wywo≥anie metody \code{IRenderable::Render()} iterujπc po mapie aktualnie uøywanego shadera.


\subsection{Kamera}
\label{Praktyka:Architektura:Kamera}
Kamera jest obiektem w przestrzeni 3D, ktÛry okreúla pozycjÍ obserwatora. Klasa \code{CCamera} zawiera nastÍpujπce parametry:
\begin{itemize}
    \item WspÛ≥rzÍdne punktu reprezentujπcego pozycjÍ kamery.
    \item Punkt patrzenia. Moøliwe jest rÛwnieø pobranie kierunku kamery uøywajπc wzoru:
$$\vec{direction} = normalize(\vec{lookAt} - \vec{position})$$
    \item Wartoúci wymagane do tworzenia macierzy widoku oraz projekcji.
\end{itemize}

DostÍpne sπ dwa tryby kamery, od ktÛrych zaleøy sposÛb uaktualniania pozycji: statyczna i dynamiczna.

\subsubsection{Statyczna}
\label{Praktyka:Architektura:Kamera:Statyczna}
Kamera statyczna zapewnia swobodne sterowanie kamerπ w okreúlonych kierunkach. Uaktualnianie pozycji polega na dodawaniu lub odejmowaniu okreúlonej wartoúci liczbowej do poszczegÛlnych sk≥adowych wektora pozycji i kierunku patrzenia. Przyk≥adowa obs≥uga ruchu do przodu zosta≥a pokazana na wydruku \ref{code:ruchKameryStatycznej}.

\begin{lstlisting}[caption={PrzesuniÍcie kamery statycznej do przodu},label={code:ruchKameryStatycznej}]
float camSpeed = 20.0f;
if(Input.CameraForward()){
	position.z += camSpeed * FPSCounter.GetElapsedTime();
	lookAt.z += camSpeed * FPSCounter.GetElapsedTime();
}
\end{lstlisting}

\subsubsection{Dynamiczna}
\label{Praktyka:Architektura:Kamera:Dynamiczna}
Kamera dynamiczna umoøliwia úledzenie pozycji okreúlonego obiektu. Wydruk \ref{code:ruchKameryDynamicznej} pokazuje przemieszczenie kamery wzglÍdem pozycji obiektu. Dodatkowo uwzglÍdniana jest odleg≥oúÊ od obiektu w poziomie (\code{distance}), odleg≥oúÊ w pionie (\code{distanceUp}) i rotacja (\code{rotation}).

\begin{lstlisting}[caption={Uaktualnienie pozycji kamery dynamicznej},label={code:ruchKameryDynamicznej}]
lookAt = followedObject->GetPosition();
float x = lookAt.x - sin(rotation)*distance;
float y = lookAt.y + distanceUp;
float z = lookAt.z - cos(rotation)*distance;
\end{lstlisting}

Sterowanie kamerπ ogranicza siÍ do obracania pozycji wokÛ≥ obiektu. Wykonywane jest to za pomocπ ruchu myszy w lewo i prawo. RÛønica w odleg≥oúci miÍdzy kolejnymi uaktualnieniami pozycji kursora jest mnoøona przez sta≥π prÍdkoúÊ kamery i dodawana lub odejmowana do wartoúci zmiennej \code{rotation}. Moøliwa jest rÛwnieø zmiana wysokoúci kamery za pomocπ ruchÛw do przodu i do ty≥u przy wciúniÍtym lewym przycisku myszy. W tym przypadku okreúlona wartoúÊ jest dodawana do obu zmiennych \code{direction} i \code{directionUp}.\\

\subsection{Obs≥uga düwiÍku}
\label{Praktyka:Architektura:Dzwiek}
Do obs≥ugi düwiÍku zosta≥a wykorzystana darmowa wieloplatformowa biblioteka \mbox{irrKlang} obs≥ugujπca wiele formatÛw takich jak:  WAV, MP3, OGG, FLAC, MOD, XM, IT, S3M. Zarzπdzaniem i odgrywaniem düwiÍkÛw zajmuje siÍ klasa \code{CSoundMgr}. G≥Ûwne zadania menedøera düwiÍku:
\begin{itemize}
    \item Tworzenie unikalnych aliasÛw do plikÛw.
    \item £adowanie i odtwarzanie düwiÍkÛw 2D i 3D.
\end{itemize}

Klasa \code{CSoundMgr} umoøliwia odtworzenie düwiÍku jeden raz lub w nieskoÒczonej pÍtli. W celu zachowania referencji do düwiÍku, przydatnej do wstrzymania lub wczeúniejszego zakoÒczenia odtwarzania, tworzony jest obiekt klasy \code{CSound}, ktÛremu przypisana zostaje unikalna nazwa. Dodawany jest on do mapy obiektÛw. KrÛtkie düwiÍki, ktÛre sπ wywo≥ywane czÍsto (np. odg≥os uderzenia obiektu lub zmiana opcji w menu) nie wymagajπ zachowywania referencji. D≥uøsze, takie jak podk≥ad muzyczny, odgrywane najczÍúciej w nieskoÒczonej pÍtli, powinny mieÊ konkretnπ nazwÍ i pozycjÍ w mapie. Niepoøπdanπ sytuacjπ jest ustawienie zapÍtlonego düwiÍku muzycznego bez stworzenia obiektu, poniewaø odgrywa≥by siÍ on aø do zamkniÍcia aplikacji.\\

Operacje dostÍpne w klasie \code{CSound} to:
\begin{itemize}
    \item Wstrzymanie/wznowienie odgrywania
    \item ZakoÒczenie odtwarzania
    \item Zatrzymanie pÍtli odtwarzania
    \item Sprawdzenie stanu odtwarzania (gra lub zosta≥ zakoÒczony)
\end{itemize}

Metoda \code{CSoundMgr::Update()} iteruje po wszystkich dostÍpnych obiektach. Najpierw usuwa obiekty, ktÛre zakoÒczy≥y odtwarzanie. Na pozosta≥ych obiektach wykonywana jest metoda \code{CSound::Update()}. 

\subsubsection{DüwiÍk 3D}
\label{Praktyka:Architektura:Dzwiek:3D}
Klasa \code{CSound3D} jest rozszerzeniem klasy \code{CSound}. Odpowiada za obs≥ugÍ düwiÍkÛw 3D. Istniejπ dwie moøliwoúci odgrywania:
\begin{itemize}
    \item Sta≥a pozycja w przestrzeni 3D. Moøliwe jest rÛwnieø odtworzenie takiego düwiÍku bez koniecznoúci tworzenia obiektu \code{CSound3D}.
    \item Pozycja dynamiczna pobierana z przypisanego obiektu. W tym przypadku jedynπ moøliwoúciπ jest stworzenie obiektu \code{CSound3D}, ktÛry podczas uaktualniania pobiera pozycjÍ obiektu i uaktualnia ustawienie düwiÍku w przestrzeni.
\end{itemize}

\subsection{Zarzπdzanie czasem - Timery}
\label{Praktyka:Architektura:Timery}
Waønym elementem kaødej gry jest wykonywanie pewnych operacji po up≥ywie okreúlonego czasu. Przyk≥adem jest zmiana stanu gry \atbold{start1} $\shortrightarrow$ \atbold{start2} po up≥ywie 4 sekund. Takøe w samej grze wystÍpujπ sytuacje, w ktÛrych np. po wyúwietleniu okna z informacjπ zostaje ono automatycznie zamkniÍte po up≥ywie kilku sekund. 

\subsubsection{Tworzenie}
\label{Praktyka:Architektura:Timery:Tworzenie}
Pojedynczy timer reprezentowany jest za pomocπ obiektu klasy \code{CTimer}. Zawiera ona niezbÍdne metody odpowiedzialne za wstrzymanie, wznowienie i sprawdzenie stanu timera. Najwaøniejszymi polami sπ czas startu oraz koÒca.\\ 

WyrÛøniamy dwa typy timerÛw:
\begin{itemize}
    \item \textbf{Prosty (\code{CTimerSimple})} wykonuje wskazanπ akcjÍ po up≥ywie ustawionego czasu.
    \item \textbf{Odliczajπcy (\code{CTimerCounting})} jest rozszerzeniem timera prostego. RÛønicπ w stosunku do poprzedniego, w ktÛrym akcja wykonywana jest tylko raz, jest ciπg≥e wykonywanie akcji, aø do momentu przekroczenia ustawionego czasu.
\end{itemize}

Przechowywaniem i uaktualnianiem timerÛw zajmuje siÍ menedøer \code{CTimerMgr}. Poza metodami pozwalajπcymi na dodawanie, usuwanie i pobieranie obiektÛw, umoøliwia teø wstrzymanie i wznowienie wszystkich timerÛw.\\

Metoda \code{CTimer::Update()} wywo≥ywana podczas uaktualniania logiki wykonuje dwie operacje:
\begin{enumerate}
    \item Wykrycie timerÛw zakoÒczonych i usuwanie ich z mapy obiektÛw.
    \item Sprawdzenie pozosta≥ych w celu ewentualnego wykonania ustalonej akcji.
\end{enumerate}

\subsubsection{Wykonywanie akcji}
\label{Praktyka:Architektura:Timery:Akcje}
Ustawienie akcji wykonywanej podczas dzia≥ania lub zakoÒczenia timera polega na stworzeniu obiektu klasy \code{CCallback} i przypisaniu go do obiektu timera. Istniejπ dwa warianty do wyboru:
\begin{itemize}
    \item Wykonanie akcji systemowej (\code{CCallbackEngine}). Umoøliwia ona wykonanie metody \code{CGame::NextStatus()}, ktÛry zmienia stan gry w zaleønoúci od poprzedniego, lub uaktualnienie czasu licznika gry (a takøe wywo≥anie odpowiednich metod w skrypcie poziomu, wiÍcej w rozdziale \ref{Praktyka:Tworzenie}).
    \item Wywo≥anie funkcji w skrypcie Lua (\code{CCallbackLua}).
\end{itemize}

\subsubsection{Timery systemowe}
\label{Praktyka:Architektura:Timery:Systemowe}
Timery wewnÍtrzne, dodawane przez silnik, zaczynajπ siÍ od przedrostka "SYSTEM". Wykorzystywane sπ do mechanizmÛw poprawiajπcych dzia≥anie aplikacji:
\begin{itemize}
    \item Reakcja na wciúniÍcie przycisku strza≥ki w gÛrÍ lub w dÛ≥ w stanie \textbf{mainMenu} powoduje zmianÍ pozycji zaznaczonego elementu. Stan przycisku pobierany jest przy kaødej iteracji pÍtli g≥Ûwnej programu, co powoduje wielokrotne wykonanie zmiany stanu wybranej pozycji w menu w ciπgu sekundy, poniewaø czas wciúniÍcia i zwolnienia przycisku na klawiaturze pokrywa siÍ najczÍúciej z kilkoma wykonaniami procesu uaktualniania. Algorytm rozwiπzujπcy omawiany problem jest nastÍpujπcy:
\begin{enumerate}
    \item Sprawdzenie istnienia timera "SYSTEM~GUITime". Jeúli istnieje - sprawdzanie zostaje przerwane.
    \item Jeúli powyøszy timer nie istnieje, nastÍpuje sprawdzenie stanu odpowiednich klawiszy i zmiana stanu elementÛw menu.
    \item Ostatnim krokiem jest ustawienie timera "SYSTEM~GUITime" (bez przypisywania øadnej akcji) na $\frac{1}{10}$ sekundy, co jest wystarczajπcym czasem, w ktÛrym uøytkownik moøe wcisnπÊ i zwolniÊ odpowiedni przycisk.
\end{enumerate}
    \item Ustawienie stanÛw \textbf{start1} i \textbf{start2} powoduje dodanie timera, ktÛry po up≥ywie 4 sekund wywo≥a akcje systemowπ, ktÛra z kolei wywo≥a metodÍ \code{CGame::NextStatus()} przechodzπc do kolejnego stanu.
\begin{lstlisting}[caption={Ustawianie zmiany stanu aplikacji po up≥ywie 4 sekund},label={code:timerZmiana}]
CTimer *timer = new CTimerSimple(4);
CCallback *callback = new CCallbackEngine(CFT_NEXTSTATUS);
timer->SetCallback(callback);
TimerMgr.AddTimer("SYSTEM start", timer);
\end{lstlisting}
    \item W grze dostÍpny jest licznik czasu, ktÛry odlicza czas do koÒca poziomu. Na øyczenie uøytkownika ustawiany jest timer o nazwie "SYSTEM~GameTime", ktÛry wywo≥uje dwie ustalone metody w skrypcie poziomu:
\begin{description}
    \item[TimeoutCounting] -- Wykonywana przez ca≥y okres dzia≥ania zegara
    \item[Timeout] -- Wykonywana po up≥yniÍciu czasu
\end{description}
\end{itemize}

\subsection{Obs≥uga skryptÛw}
\label{Praktyka:Architektura:Skrypty}
ZewnÍtrzne skrypty umoøliwiajπ przeniesienie wykonywania okreúlonych operacji na zewnπtrz kodu ürÛd≥owego. DziÍki temu zmiany w konfiguracji aplikacji lub logice poziomÛw gry mogπ zostaÊ uaktualniane bez koniecznoúci kompilacji ca≥ego projektu, a nawet w trakcie dzia≥ania programu.\\

£adowaniem oraz obs≥ugπ skryptÛw Lua zajmuje siÍ klasa \code{CScript}. Przechowywane sπ, tak jak w przypadku pozosta≥ych menedøerÛw, w mapie obiektÛw. Indeksami sπ nazwy plikÛw (bez rozszerzenia .lua). Dodanie nowego skryptu sprowadza siÍ do wykonania trzech czynnoúci:
\begin{enumerate}
    \item Stworzenie struktury przechowujπcej skrypt oraz za≥adowanie go do pamiÍci
    \item Dodanie obiektu do kontenera (mapy)
    \item Rejestracja metod
\end{enumerate}

Poza standardowymi operacjami dodawania, usuwania i pobierania obiektÛw, klasa udostÍpnia metodÍ \code{CScript::Reload()}. Umoøliwia ona wyczyszczenie sceny oraz za≥adowanych zasobÛw, a nastÍpnie ponowne uruchomienie skryptu, dziÍki czemu konfiguracja aktualnego poziomu zostaje odúwieøona.

\subsubsection{Rejestrowanie metod}
\label{Praktyka:Architektura:Skrypty:Metody}
Biblioteka Lua umoøliwia rejestrowanie statycznych metod, tym samym umoøliwiajπc ich wywo≥anie w kodzie skryptu. Odbywa siÍ to poprzez wywo≥anie funkcji \code{lua\_register()} (przyk≥adowe wywo≥anie pokazuje wydruk \ref{code:rejestracja}) przyjmujπcej jako parametry: wskaünik do struktury skryptu, nazwÍ metody (dostÍpnπ w skrypcie) oraz adres rejestrowanej funkcji.

\begin{lstlisting}[caption={Rejestracja metody},label={code:rejestracja}]
lua_register(Lua, "ShowMessage", &LuaGame::ShowMessage);
\end{lstlisting}

Aplikacja udostÍpnia wiele metod pogrupowanych w nastÍpujπce kategorie:
\begin{itemize}
    \item \textbf{Resource} -- £adowanie modeli i tekstur.
    \item \textbf{Sound} -- Odtwarzanie düwiÍkÛw.
    \item \textbf{Entity} -- Tworzenie i obs≥uga obiektÛw.
    \item \textbf{Camera} -- Zmiana typu kamery i úledzonego obiektu.
    \item \textbf{Timer} -- Dodawanie timerÛw.
    \item \textbf{Game} -- Pozosta≥e funkcje np. Pauza gry.
\end{itemize}

Kaøda metoda przyjmuje jako parametr wskaünik do skryptu, w ktÛrym zarejestrowana funkcja zosta≥a wywo≥ana. NastÍpnie sprawdzana jest iloúÊ parametrÛw przekazanych do funkcji. Metoda \code{CScript::CheckInput()} po podaniu wskaünika do skryptu oraz iloúci oczekiwanych parametrÛw zwraca \code{true} lub \code{false}. NastÍpnym krokiem jest sprawdzenie typÛw parametrÛw za pomocπ funkcji \code{lua\_isstring}, \code{lua\_isnumber} itd. Jeúli wszystko siÍ zgadza nastÍpuje pobranie wartoúci parametrÛw ze stosu i wykonanie pozosta≥ych czynnoúci.

\subsubsection{Wywo≥ywanie metod skryptowych}
\label{Praktyka:Architektura:Skrypty:Metody}
Klasa \code{CScript} umoøliwia wywo≥ywanie funkcji skryptu z poziomu kodu C++. Odbywa siÍ to w wielu przypadkach takich jak:
\begin{itemize}
    \item Zg≥oszenie kolizji miÍdzy dwoma obiektami
    \item Wykonanie akcji timera po up≥ywie wyznaczonego czasu
    \item Zmiana stanu gry
\end{itemize}

Metoda \code{CScript::CallFunction} posiada kilka wariantÛw, ktÛre umoøliwiajπ wywo≥anie wybranej funkcji okreúlonego skryptu. Parametry jakie mogπ byÊ przekazane to napis, dwa napisy, liczba, lub wywo≥anie bez parametru. Moøliwe jest rÛwnieø pobranie wartoúci zmiennej globalnej za pomocπ metody \code{CScript::GetXXXType()}, gdzie \code{XXX} jest jednym z trzech typÛw:
\begin{itemize}
    \item \textbf{String} - WartoúÊ tekstowa
    \item \textbf{Integer} - Liczba ca≥kowita
    \item \textbf{Float} - WartoúÊ zmiennoprzecinkowa
\end{itemize}
W przypadku niepowodzenia lub braku ustawionej wartoúci zmiennej, zwracana jest wartoúÊ domyúlna ustawiana.

\section{Tworzenie gry AtBall}
\label{Praktyka:Tworzenie}
W celu prezentacji moøliwoúci przygotowanego silnika, stworzona zosta≥a prosta gra platformowa. Niniejszy rozdzia≥ opisuje proces jej powstawania, od opisu pomys≥u, do implementacji poszczegÛlnych elementÛw

\subsection{Opis gry}
\label{Praktyka:Tworzenie:Opis}
AtBall to zrÍcznoúciowa gra platformowa. Gracz steruje jednym z trzech typÛw kul:
\begin{itemize}
    \item \textbf{KamieÒ} -- Sterowanie jest utrudnione, a w niektÛrych sytuacjach, takich jak stromy podjazd pod gÛrÍ, nawet niemoøliwe. Zaletπ tego typu kuli jest moøliwoúÊ ≥atwego przesuwania na raz kilku obiektÛw (np. skrzyÒ).
    \item \textbf{Papier} -- Kula papierowa imituje zgniecionπ kartkÍ papieru. Jej lekka waga znaczπco u≥atwia sterowanie, jednak w niektÛrych przypadkach wymaga duøej zrÍcznoúci. Przesuwanie ciÍøszych obiektÛw jest utrudnione lub niemoøliwe. G≥Ûwnπ zaletπ tego typu jest interakcja z wiatrakiem, ktÛry umoøliwia wlatywanie na niedostÍpne dla innych typÛw poziomy.
    \item \textbf{Drewno} -- Najwygodniejszy w sterowaniu typ kuli. årednia waga umoøliwia proste przesuwanie jednego obiektu, a takøe podjazd pod gÛrÍ.
\end{itemize}

Typ kuli zmienia siÍ po najechaniu na odpowiedniπ platformÍ. Po≥oøenie tych obiektÛw jest zaleøne od aktualnych przeszkÛd do pokonania lub zadaÒ do wykonania. Kaøda platforma ma przypisany jeden docelowy rodzaj kuli.\\

Celem gry jest dotarcie do koÒca poziomu, zbierajπc przy tym obiekty podobne do trÛjwymiarowej gwiazdy zwane Aurorami. Naleøy zebraÊ odpowiedniπ ich iloúÊ, aby odblokowaÊ moøliwoúÊ ukoÒczenia planszy. Przyk≥adowym zadaniem jest zebranie 10 Auror w celu aktywowania wiatraka, dziÍki ktÛremu papierowa kula podleci na platformÍ koÒczπcπ poziom.

\subsection{WstÍpna konfiguracja}
\label{Praktyka:Tworzenie:Konfiguracja}
\subsubsection{Zmienne konfiguracyjne}
\label{Praktyka:Tworzenie:Konfiguracja:Zmienne}
Skrypt \textbf{config.lua} zawiera informacje, ktÛre muszπ zostaÊ ustawione przed uruchomieniem aplikacji:
\begin{itemize}
    \item \textbf{screenSize} -- Numer wybranej rozdzielczoúci. DostÍpne wartoúci to:
\begin{description}
    \item[1] 800x600
    \item[2] 1024x768
    \item[3] 1280x800
    \item[4] 1280x1024
    \item[5] 1440x900
    \item[6] 1680x1050
    \item[7] 1920x1200
\end{description}
Preferowanym ustawieniem jest rozdzielczoúÊ panoramiczna.
    \item \textbf{skyboxTexture} -- åcieøka do pliku DDS zawierajπcego teksturÍ t≥a sceny.
\begin{lstlisting}[caption={Ustawienie tekstury SkyBoxa},label={code:skybox}]
skyboxTexture = "media/textures/skybox/Islands.dds"
\end{lstlisting}
    \item \textbf{level} -- Nazwa pliku skryptu pierwszego poziomu (bez rozszerzenia .lua).
\end{itemize}

\subsubsection{Obs≥uga zmiany stanu gry}
\label{Praktyka:Tworzenie:Konfiguracja:ZmianaStanu}
W pliku konfiguracyjnym istnieje moøliwoúÊ wykonania dowolnych czynnoúci podczas zmiany stanu gry. S≥uøπ do tego metody \code{onEngineStart()}, \code{onScreen1()}, \code{onScreen2()}, \code{onMainMenu()} itd., ktÛre przyjmujπ jako parametr poprzedni stan gry. Przyk≥adowo w metodzie wykonywanej po starcie silnika moøna przygotowaÊ düwiÍki takie jak t≥o menu, niezaleønych od konkretnego poziomu, w metodzie \code{onScreen1} rozpoczπÊ odtwarzanie muzyki, a w \code{onLoading} wy≥πczyÊ jπ i pozwoliÊ skryptowi poziomu na ustawienie odpowiedniego t≥a muzycznego.\\

Przygotowane zosta≥y rÛwnieø metody wykonywane przy zmianie pozycji w menu g≥Ûwnym (\code{onMenuChange()}) oraz wybraniu konkretnej pozycji (\code{onMenuEnter()}), ktÛre rÛwnieø umoøliwiajπ odtworzenie odpowiednich düwiÍkÛw.

\subsection{Tworzenie sceny}
\label{Praktyka:Tworzenie:Scena}
Aplikacja udostÍpnia odpowiednie metody, s≥uøπce do dodawania zasobÛw oraz tworzenia obiektÛw na scenie, a takøe ustawiania ich w≥aúciwoúci.\\

RÍczne tworzenie sceny, zw≥aszcza rozbudowanej, jest ma≥o wygodne i nieefektywne. Autor zdecydowa≥ siÍ na wykorzystanie darmowego edytora úwiata IrrEdit firmy AMBIERA. Umoøliwia on dodawanie obiektÛw, ustawianie ich pozycji, orientacji, skali oraz tekstury. 

\begin{figure}[h]
\centering
\includegraphics[width=100mm]{img/irredit.jpg}
\caption{Edytor úwiata IrrEdit}
\label{img:irredit}
\end{figure}

Gotowa scena zapisywana jest w formacie XML~\footnote{Extensible Markup Language}. Aby dodaÊ modele do sceny gry naleøy wywo≥aÊ funkcjÍ \code{ResourceParseIrrXML()}, ktÛra przyjmuje dwa parametry: úcieøkÍ do pliku XML wygenerowanego w programie IrrEdit oraz nazwÍ metody wywo≥ywanej dla kaødego obiektu. Metoda ta zawiera 12 parametrÛw:
\begin{enumerate}
    \item Nazwa obiektu
    \item Nazwa pliku modelu i tekstury
    \item Po trzy wartoúci dla pozycji, rotacji i skali, odpowiednio dla osi X, Y i Z
\end{enumerate}

Kaøde wywo≥anie tej metody powinno sprawdzaÊ, czy niezbÍdne zasoby (model i tekstura) zosta≥y za≥adowane, lub za≥adowaÊ je. NastÍpnie nastÍpuje dodanie obiektu oraz (na podstawie modelu i tekstury) ustawienie odpowiednich w≥aúciwoúci. Wydruk \ref{code:parser} pokazuje przyk≥adowe dodanie modelu úmig≥a wiatraka.
\begin{lstlisting}[language=Pascal,caption={Dodawanie obiektu wiatraka},label={code:parser}]
function IrrXmlParserCallback(name, mesh, texture, posX, posY, posZ, rotX, rotY, rotZ, scaleX, scaleY, scaleZ)
	(...) -- pominiÍte sprawdzanie za≥adowania modelu i tekstury
	if mesh == "wiatrak.x" then
		return CreateWiatrak(name, mesh, texture, posX, posY, posZ, rotX, rotY, rotZ, scaleX, scaleY, scaleZ)
	end
	(...) -- sprawdzanie i ewentualne dodanie innych obiektÛw
end
function CreateWiatrak(name, mesh, texture, posX, posY, posZ, rotX, rotY, rotZ, scaleX, scaleY, scaleZ)
	local name2 = CreateEntity(name, mesh, texture, posX, posY, posZ, rotX, rotY, rotZ, scaleX, scaleY, scaleZ, 0, EntityType.noPhysx, "")
	EntitySetAnimation(name2, 0, 600.0, 0)
end
\end{lstlisting}

\subsection{Poziomy gry}
\label{Praktyka:Tworzenie:Poziomy}
Poziomy gry sπ przygotowywane w osobnych skryptach Lua. Nazwa pierwszego jest ustawiana w pliku konfiguracyjnym. Kaødy z kolejnych zawiera informacje o nastÍpnym, przechowujπc nazwÍ skryptu w zmiennej \code{NextLevel}. Jeúli taka nie wystÍpuje, po zakoÒczeniu aktualnego poziomu nastÍpuje koniec gry.\\

TwÛrca poziomu moøe ustawiÊ czas w sekundach za pomocπ funkcji \code{SetTimeout()}, ktÛra uruchamia licznik odliczajπcy do zera. Jego dzia≥anie moøe zostaÊ obs≥uøone nastÍpujπcymi metodami wywo≥ywanymi przez aplikacjÍ:
\begin{itemize}
    \item \textbf{TimeoutCounting} wywo≥ywana ciπgle, przekazujπca w parametrze czas w milisekundach pozosta≥y do koÒca odliczania. Moøe byÊ np. wykorzystana do zmiany t≥a muzycznego, jeúli graczowi pozostanie jedna minuta do koÒca.
    \item \textbf{Timeout} wykonywana po dojúciu licznika do zera. Poøπdanπ akcjπ jest wyúwietlenie informacji o zakoÒczeniu poziomu, a nastÍpnie wywo≥anie funkcji \code{Reset()} ktÛra ≥aduje poziom od nowa.
\end{itemize}

\subsection{Elementy rozgrywki}
\label{Praktyka:Tworzenie:Elementy}
Rozdzia≥ ten zawiera opis implementacji kilku elementÛw wykorzystywanych w grze AtBall.

\subsubsection{Platforma zmiany typu kuli}
\label{Praktyka:Tworzenie:Elementy:Platforma}
Platforma zmiany typu kuli jest reprezentowana przez p≥aski kwadratowy model z kulistym wg≥Íbieniem. Ustawiane sπ trzy rÛøne tekstury, ktÛre wskazujπ na typ, na jaki zostanie zmieniona kula po wjechaniu we wg≥Íbienie.\\
\begin{figure}[h]
\centering
\includegraphics[width=60mm]{img/zmianaModel.jpg}
\caption{Model reprezentujπcy platformÍ zmiany kuli}
\label{img:zmianaModel}
\end{figure}

Na scenie istniejπ trzy modele reprezentujπce konkretny rodzaj typu kuli. Jeden jest wyúwietlany i obs≥ugiwany przez sterowanie, natomiast dwa pozosta≥e sπ ukryte. Zmiana typu kuli powoduje ukrycie aktualnego obiektu i przeniesienie nowego na pozycjÍ starego.\\

Proces zmiany wyglπda nastÍpujπco:
\begin{enumerate}
    \item Wykrycie kolizji kuli z obiektem. Kula docelowo powinna znajdowaÊ siÍ wewnπtrz wg≥Íbienia, aby mog≥a bezw≥adnie stoczyÊ siÍ w stronÍ úrodka. Wykrycie kolizji z ca≥ym modelem nie daje satysfakcjonujπcego efektu, poniewaø znajdujπ siÍ tam p≥askie elementy. Rozwiπzaniem tego problemu jest dynamiczne stworzenie obiektu odrobinÍ mniejszego od w≥aúciwego modelu, oraz obs≥uøenie zdarzenia wejúcia w kontakt za pomocπ triggerÛw. Dwie funkcje pokazane na wydruku \ref{code:trigger} tworzπ obiekt s≥uøπcy wykrywania kolizji o wymiarach 1.0 x 0.1 x 1.0 (podane wymiary zostanπ odpowiednio przeskalowane w zaleønoúci od ustawionej skali obiektu), a nastÍpnie przypisujπ obs≥uøenie zdarzenia kontaktowego w funkcji \code{zmianaTypuKuliStart()}.
\begin{lstlisting}[language=Pascal,caption={Tworzenie triggera},label={code:trigger}]
EntitySetTrigger(platforma, 1.0, 0.1, 1.0)
EntitySetTriggerCallback(name2, "zmianaTypuKuliStart", Trigger.onEnter)
\end{lstlisting}
    \item Wyzerowanie si≥ dzia≥ajπcych na obiekt oraz dezaktywowanie sterowania. Umoøliwia to kuli bezw≥adne opadniÍcie w stronÍ úrodka wg≥Íbienia.
\begin{lstlisting}[language=Pascal,caption={Zerowanie si≥},label={code:zerowanie}]
EntityClearForces(aktualnaKula)
EntityDisableUpdateObject(aktualnaKula)
\end{lstlisting}
    \item OpadniÍcie kuli, w zaleønoúci od jej masy, wymaga czasu. W zwiπzku z tym, po wy≥πczeniu sterowania i dezaktywowaniu si≥, dodawany jest timer, ktÛry po 4 sekundach wykonuje kolejnπ funkcjÍ.
\begin{lstlisting}[language=Pascal,caption={Dodanie timera zmiany kuli},label={code:timerZmiany}]
TimerAdd(nazwaTimera, 4.0, TimerType.simple, TimerCallback.Lua, "zmianaTypuKuliEnd")
\end{lstlisting}
    \item Po up≥ywie czasu nastÍpuje zmiana typu. Wykonywane sπ nastÍpujπce operacje:
\begin{itemize}
    \item Pobranie pozycji aktualnej kuli i ukrycie obiektu.
    \item Ustawienie pobranej pozycji obiektowi reprezentujπcemu nowy typ kuli, a nastÍpnie pokazanie go.
    \item Uaktualnienie ustawienia kamery (przypisanie nowego obiektu do úledzenia) oraz ustawienie sterowania.
\end{itemize}

\end{enumerate}
\subsubsection{Wiatrak}
\label{Praktyka:Tworzenie:Elementy:Wiatrak}
Wiatrak symulujπcy dzia≥anie wiatru wiejπcego w okreúlonym kierunku jest zbudowany z dwÛch niezaleønych modeli. \\

Pierwszym obiektem jest úmig≥o wiatraka, ktÛre zostaje umieszczone na scenie jako prosty model (bez tworzenia aktora symulacji fizycznej). W celu nadania rotacji wywo≥ana zostaje funkcja \code{EntitySetAnimation()}, ktÛra uruchamia prostπ animacjÍ obiektu obracajπc go wed≥ug wskazanych osi i prÍdkoúci przypisanej do kaødej z nich.\\
\begin{figure}[h]
\centering
\includegraphics[width=100mm]{img/wiatrakModel.jpg}
\caption{åmig≥o i podstawa wiatraka}
\label{img:wiatrakModel}
\end{figure}
Kratka, ktÛra stanowi podstawÍ wiatraka, reprezentowana jest przez obiekt, umieszczony w odpowiedniej odleg≥oúci od úmig≥a. W celu dodania pola si≥owego, ktÛre wprawia obiekt znajdujπcy siÍ w jej zasiÍgu w ruch, naleøy wywo≥aÊ funkcjÍ \code{EntitySetForceField()}. OprÛcz nazwy obiektu, do ktÛrego zostanie przypisany efekt, zostajπ podane wartoúci wektora, ktÛre wskazujπ na kierunek dzia≥ania si≥y. Ostatni parametr okreúla wartoúÊ si≥y, z jakπ pole dzia≥a na obiekty. Wymiar pola si≥owego dostosowuje siÍ do skali obiektu. Rozszerzany jest nie tylko wymiar podstawy, ale rÛwnieø wysokoúÊ pola, dziÍki czemu im wiÍkszy wiatrak tym wyøej obiekty uniosπ siÍ wchodzπc w jego zakres.\\

Docelowym dzia≥aniem wiatraka jest oddzia≥ywanie wy≥πcznie na kulÍ papierowπ. Ograniczeniem domyúlnej budowy pola si≥owego w bibliotece PhysX jest brak uwzglÍdniania masy obiektu, toteø na wszystkie obiekty nak≥adana jest jednakowa si≥a. Aby rozwiπzaÊ ten problem autor zdecydowa≥ siÍ na w≥πczanie wszystkich wiatrakÛw, jeúli typ kuli zostanie zmieniony na papierowy. W przeciwnym wypadku pole si≥owe zostaje usuniÍte. Pozostawienie animacji obracajπcego siÍ úmig≥a daje wraøenie poprawnego dzia≥ania wiatraka, jednak najechanie pozosta≥ymi typami kul nie powoduje øadnej reakcji.

\subsubsection{Zbieranie obiektÛw}
\label{Praktyka:Tworzenie:Elementy:Zbieranie}
Zadaniem gracza jest zebranie odpowiedniej iloúci gwiazdek zwanych Aurorami. Obiekty te wiszπ w powietrzu jednoczeúnie obracajπc siÍ wokÛ≥ w≥asnej osi.\\
\begin{figure}[h]
\centering
\includegraphics[width=50mm]{img/auroraModel.jpg}
\caption{Model Aurory}
\label{img:auroraModel}
\end{figure}
Dodanie nowego obiektu wymaga uøycia ≥πczenia obiektÛw (rozdzia≥ \ref{Praktyka:Architektura:Obiekty:Laczenie}) z dwÛch powodÛw:
\begin{itemize}
    \item Dodanie sta≥ej animacji rotacji jest dostÍpne tylko dla prostych obiektÛw
    \item Wykrycie kolizji z obiektem w celu inkrementacji licznika zebranych Auror wymaga stworzenia aktora w symulacji fizycznej
\end{itemize}

Pierwszym krokiem jest dodanie widzialnego obiektu, oraz ustawienie animacji. NastÍpnie nastÍpuje stworzenie obiektu symulacji, tworzπc kszta≥t kulisty aktora. Uøyty zostaje do tego wczeúniej za≥adowany model obiektu widzialnego. Ostatniπ operacjπ jest po≥πczenie dwÛch obiektÛw w jeden z≥oøony.
\begin{lstlisting}[language=Pascal,caption={Tworzenie po≥πczonych obiektÛw},label={code:laczenieAuror}]
local nameRender = CreateEntity(name, mesh, texture, posX, posY, posZ, rotX, rotY, rotZ, scaleX, scaleY, scaleZ, 0, EntityType.noPhysx, "")
EntitySetAnimation(nameRender, 50.0, 200.0, 25.0)
local namePhysx = CreateEntity(nameRender .. "PhysX", mesh, texture, posX, posY, posZ, rotX, rotY, rotZ, scaleX, scaleY, scaleZ, PhysxShape.sphere, EntityType.physx, "")
EntityRaiseBodyFlag(namePhysx, BodyFlag.kinematic)
EntitySetBindObject(namePhysx, nameRender)
\end{lstlisting}

Algorytm zebrania jednej Aurory prezentuje siÍ nastÍpujπco:
\begin{enumerate}
    \item Przypisanie zdarzenia wykrywajπcego wejúcie w obiekt Aurory poprzez stworzenie dodatkowego obiektu o wymiarach odrobinÍ wiÍkszych od w≥aúciwego aktora:
\begin{lstlisting}[language=Pascal,caption={Przypisanie reakcji na kolizjÍ z obiektem Aurory},label={code:kolizjaAurora}]
EntitySetTrigger(namePhysx, 1.1, 1.1, 1.1)
EntitySetTriggerCallback(namePhysx, "zebranieAurory", Trigger.onEnter)
\end{lstlisting}
    \item Obs≥uøenie wywo≥anej funkcji \code{zebranieAurory()}, ktÛra wykonuje nastÍpujπce operacje:
\begin{itemize}
    \item Sprawdzenie czy kolizja nastπpi≥a z kulπ.
    \item Ukrycie obiektu Aurory razem z dezaktywacjπ obiektu do wykrywania kolizji.
    \item ZwiÍkszenie licznika zebranych Auror o 1 i uaktualnienie nowej wartoúci na ekranie.
\begin{lstlisting}[language=Pascal,caption={Uaktualnienie licznika zebranych Auror},label={code:uaktualnienieLicznika}]
ZebraneAurory = ZebraneAurory + 1
SetStarsCount(ZebraneAurory)
\end{lstlisting}
\end{itemize}
\end{enumerate}

% ********** Koniec rozdzia≥u **********

% ********** Rozdzia≥ 4 - PODSUMOWANIE **********
\chapter{Podsumowanie}
\label{Podsumowanie}
\section{Ocena projektu}
\label{Podsumowanie:Ocena}
G≥Ûwnym za≥oøeniem projektu by≥o stworzenie silnika graficznego, umoøliwiajπcego oddzielenie warstwy logicznej gry od kodu aplikacji. Cel ten zosta≥ osiπgniÍty, czego dowodem jest przygotowana gra komputerowa. Skrypty opisujπce poszczegÛlne poziomy umoøliwiajπ programiúcie budowanie sceny, ustalenie celu ukoÒczenia planszy, a takøe kreacjÍ dowolnych zadaÒ, ktÛre muszπ zostaÊ wykonane.\\

Przygotowanie tak rozbudowanej aplikacji jakπ jest gra komputerowa wymaga≥o kilku miesiÍcy intensywnej pracy. Zaimplementowanie wszystkich funkcjonalnoúci przewidzianych w procesie planowania okaza≥o siÍ niemoøliwe. G≥Ûwnymi powodami by≥y:
\begin{itemize}
    \item Ograniczenia czasowe. Zaawansowane gry komputerowe wymagajπ nawet kilku lat pracy i duøego zespo≥u programistycznego. Autor przygotowywa≥ pracÍ w jednoosobowym zespole, tak wiÍc koniecznoúciπ by≥a implementacja jedynie najwaøniejszych elementÛw aplikacji, skupiajπcych siÍ na g≥Ûwnym za≥oøeniu projektu. Z tego powodu pominiÍte zosta≥o rozbudowywanie czÍúci graficznej aplikacji, odpowiedzialnej za efekty takie jak system czπsteczek.
    \item Niedostateczna wiedza i doúwiadczenie w projektowaniu i implementowaniu duøych projektÛw. Skutkowa≥o to czÍstym przepisywaniem wielu elementÛw (a nawet ca≥ego projektu) na nowo.
\end{itemize}
Mimo wielu napotkanych trudnoúci, autorowi uda≥o siÍ stworzyÊ od podstaw funkcjonalny silnik graficzny, przygotowany do dalszego rozwoju poszczegÛlnych elementÛw, miÍdzy innymi:
\begin{itemize}
    \item Zarzπdzanie GUI z poziomu skryptÛw.
    \item Dodanie obs≥ugi úwiate≥, cieni i efektÛw czπsteczkowych.
    \item £πczenie obiektÛw za pomocπ joint'Ûw (funkcja dostÍpna w bibliotece PhysX).
\end{itemize}
